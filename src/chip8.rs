use core::panic;
use std::{
    fs::{self},
    ops::Range,
    path::{Path, PathBuf},
    thread,
    time::{Duration, Instant, SystemTime},
};

use rand::{Rng, SeedableRng, rngs::SmallRng};
use sdl2::{
    EventPump, event::Event, keyboard::Keycode, pixels::Color, rect::Point, render::Canvas,
};

const REGISTERS_LEN: usize = 16;
const MEM_LEN: usize = 0x1000;
const STACK_LEN: usize = 16;
const FONTSET_ADDR: Addr = 0x050;
const FONTSET_LEN: usize = 0x50;
const FONTSET: [u8; FONTSET_LEN] = [
    0xf0, 0x90, 0x90, 0x90, 0xf0, /* 0 */
    0x20, 0x60, 0x20, 0x20, 0x70, /* 1 */
    0xf0, 0x10, 0xf0, 0x80, 0xf0, /* 2 */
    0xf0, 0x10, 0xf0, 0x10, 0xf0, /* 3 */
    0x90, 0x90, 0xf0, 0x10, 0x10, /* 4 */
    0xf0, 0x80, 0xf0, 0x10, 0xf0, /* 5 */
    0xf0, 0x80, 0xf0, 0x90, 0xf0, /* 6 */
    0xf0, 0x10, 0x20, 0x40, 0x40, /* 7 */
    0xf0, 0x90, 0xf0, 0x90, 0xf0, /* 8 */
    0xf0, 0x90, 0xf0, 0x10, 0xf0, /* 9 */
    0xf0, 0x90, 0xf0, 0x90, 0x90, /* A */
    0xe0, 0x90, 0xe0, 0x90, 0xe0, /* B */
    0xf0, 0x80, 0x80, 0x80, 0xf0, /* C */
    0xe0, 0x90, 0x90, 0x90, 0xe0, /* D */
    0xf0, 0x80, 0xf0, 0x80, 0xf0, /* E */
    0xf0, 0x80, 0xf0, 0x80, 0x80, /* F */
];
const INPUT_KEYS_LEN: usize = 16;

const DISPLAY_WIDTH: usize = 128;
const DISPLAY_HEIGHT: usize = 64;
const PIXEL_ON: u32 = 0xffffffff;
const PIXEL_OFF: u32 = 0x00000000;
const PIXEL_SIZE: u32 = 5;
const FOREGROUND_COLOR: Color = Color::WHITE;
const BACKGROUND_COLOR: Color = Color::BLACK;

const START_ADDR: Addr = 0x200;

const UPDATES_PER_SECOND: u64 = 660;

const FRAMES_PER_SECOND: u64 = 60;

pub const ALLOWED_FILE_EXTENSIONS: &[&str] = &["ch8"];

type Addr = u16;
type Reg = u8;
type Opcode = u16;

#[derive(Clone, Copy, Debug)]
pub enum Value {
    Register(Reg),
    Immediate(u8),
}

#[derive(Debug)]
pub struct Chip8 {
    registers: [u8; REGISTERS_LEN],
    memory: [u8; MEM_LEN],

    /** Index Register. Stores an index into memory. */
    ir: Addr,

    /** Program Counter. Stores address of currently executing instruction in memory. */
    pc: Addr,

    /** Call Stack. Stores return addresses of CALL instructions. */
    stack: [Addr; STACK_LEN],

    /** Stack Pointer. Stores index of current return address in the call stack. */
    sp: u8,

    /** Delay Timer. If not zero, decrements by one each clock cycle. */
    dt: u8,

    /** Sound Timer. Behaves the same as delay timer, but a single note will buzz when non-zero. */
    st: u8,

    /** Input Keys. Stores whether each of the 16 input keys is pressed or not pressed. */
    input: [bool; 16],

    /** Monochrome Display Memory. A memory buffer storing the graphics to display. */
    display_memory: [[u32; DISPLAY_WIDTH]; DISPLAY_HEIGHT],

    /** Random Number Generator. Generates random numbers. */
    rng: SmallRng,

    /** Random Byte. The current random byte generated by the random number generator. */
    rand: u8,

    quirks: Quirks,

    is_running: bool,
    is_suspended: bool,
    is_in_extended_mode: bool,

    /** Current system tick. */
    tick: u64,

    /** RPL Flag Registers. Used to save the registers for the Super-Chip instruction */
    rpl: [u8; REGISTERS_LEN],
}

/** Struct storing the differences in behaviour between the various Chip8 versions. */
#[derive(Debug)]
pub struct Quirks {
    /** VF Reset. The `AND`, `OR`, and `XOR` opcodes reset the flags register (VF) to zero. */
    vf_reset: bool,

    /** Memory. The register `SAVE` and `LOAD` opcodes increment the Index Register. */
    memory: bool,

    /** Display Wait. Drawing sprites waits for the vertical blank interrupt. */
    display_wait: bool,

    /** Clipping. Sprites drawn at the bottom edge of the screen get clipped instead of wrapping. */
    clipping: bool,

    /** Shifting. The `SHIFT` opcodes only operate on `Vx` instead of storing the shifted `Vy` in `Vx`. */
    shifting: bool,

    /** Jumping. The `JPV0` opcode doesn't use V0, but instead `Vx` where `x` is the highest 4 bits of `addr` (i.e. `xnn`). */
    jumping: bool,
}

impl Quirks {
    const CHIP8: Self = Self {
        vf_reset: true,
        memory: true,
        display_wait: true,
        clipping: true,
        shifting: false,
        jumping: false,
    };
}

#[derive(Debug)]
pub enum Chip8Error {
    IndexOutOfRange(usize),
}

enum DecodeError {
    InvalidSecondaryOpcode(u8, u8),
}

/**
 * Vx means `registers[x]`
 */
#[derive(Clone, Copy, Debug)]
pub enum Instruction {
    /** Suspend execution */
    Suspend,

    /** Scroll display `n` lines down. */
    ScrollDown(u8),

    /** Clear the screen. */
    Clear,

    /** Return from a subroutine. */
    Return,

    /** Scroll display 4 pixels right. */
    ScrollRight,

    /** Scroll display 4 pixels left. */
    ScrollLeft,

    /** Exit CHIP Interpreter. */
    ExitChip,

    /** Disable extended screen mode. */
    DisableExtendedScreen,

    /** Enable extended screen mode for full screen graphics. */
    EnableExtendedScreen,

    /** Jump to location `addr`. */
    Jump(Addr),

    /** Call subroutine at `addr`. */
    Call(Addr),

    /** Skip next instruction if `Vx == v`. */
    SkipIfEqual { x: Reg, v: Value },

    /** Skip next instruction if `Vx != v`. */
    SkipIfNotEqual { x: Reg, v: Value },

    /** Set value of `Vx` to `v`. */
    Load { x: Reg, v: Value },

    /** Set value of `Vx` to `Vx + v`. Set `Vf = 1` if `v` is a register and `Vx + v > 255`. */
    Add { x: Reg, v: Value },

    /** Set value of `Vx` to `Vx | Vy`. */
    Or { x: Reg, y: Reg },

    /** Set value of `Vx` to `Vx & Vy`. */
    And { x: Reg, y: Reg },

    /** Set value of `Vx` to `Vx ^ Vy`. */
    Xor { x: Reg, y: Reg },

    /** Set `Vf = 1` if `Vx > Vy`. Then set value of `Vx` to `Vx - Vy`. */
    Sub { x: Reg, y: Reg },

    /** Set `Vf = 1` if least significant bit of `Vx` is one. Then set value of `Vx` to `Vx >> 1`. */
    ShiftRight { x: Reg, y: Reg },

    /** Set `Vf = 1` if `Vy > Vx`. Then set value of `Vx` to `Vx - Vy`. */
    SubNegative { x: Reg, y: Reg },

    /**  Set `Vf = 1` if most significant bit of `Vx` is one. Then set value of `Vx` to `Vx << 1`. */
    ShiftLeft { x: Reg, y: Reg },

    /** Set register `I` to `addr`. */
    LoadIndex(Addr),

    /** Jump to location `addr + V0`. */
    JumpOffset(Addr),

    /** Set `Vx` to a newly generated random byte ANDed with `mask`. */
    Random { x: Reg, mask: u8 },

    /** Display an n-byte sprite starting at location `I` at `(Vx, Vy)`. Set `Vf = collision`. */
    Draw { x: Reg, y: Reg, n: u8 },

    /** Skip next instruction if key with the value in `Vx` is pressed. */
    SkipIfKeyPressed { x: Reg },

    /** Skip next instruction if key with the value in `Vx` is NOT pressed. */
    SkipIfKeyNotPressed { x: Reg },

    /** Set `Vx = DT`. */
    LoadDtIntoRegister { x: Reg },

    /** Wait for a key press, then store value of key in `Vx`. */
    LoadKeyPress { x: Reg },

    /** Set `DT = Vx`. */
    LoadRegisterIntoDt { x: Reg },

    /** Set `ST = Vx`. */
    LoadRegisterIntoSt { x: Reg },

    /** Set `I` to `I + Vx`. */
    AddIndex { x: Reg },

    /** Set `I` to location of digit sprite corresponding to value in `Vx`. */
    LoadDigitIndex { x: Reg },

    /** Set `I` to location of extended digit sprite corresponding to value in `Vx`. */
    LoadExtendedDigitIndex { x: Reg },

    /** Store BCD representation of `Vx` in location `I`, `I+1` and `I+2`. */
    LoadBcd { x: Reg },

    /** Store `V0` to `Vx` in memory, starting at location `I`. */
    StoreRegisters { x: Reg },

    /** Read registers `V0` to `Vx` from memory starting at location `I`. */
    LoadRegisters { x: Reg },

    /** Store registers `V0` to `Vx` in RPL user flags (x <= 7). */
    StoreRegistersRPL { x: Reg },

    /** Load registers `V0` to `Vx` from RPL user flags (x <= 7). */
    LoadRegistersRPL { x: Reg },
}

fn bitmask(bits: Range<u16>) -> u16 {
    let range = Range {
        start: bits.start,
        end: bits.end.min(16),
    };
    range.fold(0, |acc, i| acc | (0x1 << i))
}

fn get_bits(value: u16, bits: Range<u16>) -> u16 {
    let start = bits.start;
    (value & bitmask(bits)) >> start
}

pub fn find_roms(dir: &Path, search_recursively: bool) -> Vec<PathBuf> {
    fs::read_dir(dir)
        .expect("failed to list entries in dir")
        .filter_map(|p| p.ok())
        .flat_map(|p| {
            let file_type = p
                .file_type()
                .expect("failed reading file type of dir entry");
            if file_type.is_file() {
                if let Some(ext) = p.path().extension() {
                    if ALLOWED_FILE_EXTENSIONS.contains(&ext.to_str().unwrap()) {
                        vec![p.path()]
                    } else {
                        Vec::new()
                    }
                } else {
                    Vec::new()
                }
            } else if search_recursively && file_type.is_dir() {
                find_roms(&p.path(), search_recursively)
            } else {
                Vec::new()
            }
        })
        .collect()
}

impl Chip8 {
    pub fn new() -> Self {
        let mut memory = [0; MEM_LEN];

        for (dst, src) in memory[FONTSET_ADDR as usize..].iter_mut().zip(FONTSET) {
            *dst = src;
        }

        let mut rng = SmallRng::seed_from_u64(
            SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_secs(),
        );
        let rand = rng.random_range(0x0..=u8::MAX);

        Self {
            registers: [0x0; REGISTERS_LEN],
            memory,
            ir: 0x0,
            pc: START_ADDR,
            stack: [0x0; STACK_LEN],
            sp: 0x0,
            dt: 0x0,
            st: 0x0,
            input: [false; INPUT_KEYS_LEN],
            display_memory: [[PIXEL_OFF; DISPLAY_WIDTH]; DISPLAY_HEIGHT],
            rng,
            rand,
            quirks: Quirks::CHIP8,
            is_running: false,
            is_suspended: false,
            is_in_extended_mode: false,
            tick: 0,
            rpl: [0x0; REGISTERS_LEN],
        }
    }

    pub fn load_rom<P>(&mut self, filepath: &P) -> Result<(), Chip8Error>
    where
        P: AsRef<Path> + ?Sized,
    {
        self.load(
            &fs::read(filepath).expect("couldn't open ROM file"),
            START_ADDR,
        )?;
        Ok(())
    }

    fn load(&mut self, bytes: &[u8], addr: Addr) -> Result<(), Chip8Error> {
        let addr = addr as usize;
        if addr + bytes.len() > self.memory.len() {
            return Err(Chip8Error::IndexOutOfRange(addr + bytes.len() - 1));
        }
        for (dst, src) in self.memory[addr..].iter_mut().zip(bytes) {
            *dst = *src;
        }
        Ok(())
    }

    pub fn run(&mut self) {
        let sdl_ctx = sdl2::init().unwrap();
        let video = sdl_ctx.video().unwrap();

        let width = DISPLAY_WIDTH as u32 * PIXEL_SIZE;
        let height = DISPLAY_HEIGHT as u32 * PIXEL_SIZE;
        let window = video
            .window("chip8 emulator", width, height)
            .position_centered()
            .build()
            .unwrap();

        let mut events = sdl_ctx.event_pump().unwrap();

        let mut canvas = window.into_canvas().build().unwrap();
        canvas.set_draw_color(BACKGROUND_COLOR);
        canvas.clear();
        canvas.present();

        self.is_running = true;

        let duration_per_update = Duration::from_micros(1_000_000 / UPDATES_PER_SECOND);
        let mut last_update = Instant::now() - duration_per_update;

        let duration_per_frame = Duration::from_micros(1_000_000 / FRAMES_PER_SECOND);
        let mut last_render = Instant::now() - duration_per_frame;

        while self.is_running {
            self.handle_events(&mut events);
            if last_update.elapsed() >= duration_per_update {
                last_update = Instant::now();

                if self.is_suspended {
                    continue;
                }

                self.frame_cycle();
            }
            if last_render.elapsed() >= duration_per_frame {
                last_render = Instant::now();
                if self.dt > 0 {
                    self.dt -= 1;
                }
                if self.st > 0 {
                    self.st -= 1;
                }

                self.draw(&mut canvas).expect("rendering driver failed");
            }
            thread::sleep(Duration::from_micros(100));
        }
    }

    fn handle_events(&mut self, events: &mut EventPump) {
        fn keycode_to_input(keycode: Keycode) -> Option<usize> {
            Some(match keycode {
                Keycode::NUM_1 => 0x1,
                Keycode::NUM_2 => 0x2,
                Keycode::NUM_3 => 0x3,
                Keycode::NUM_4 => 0xc,
                Keycode::Q => 0x4,
                Keycode::W => 0x5,
                Keycode::E => 0x6,
                Keycode::R => 0xd,
                Keycode::A => 0x7,
                Keycode::S => 0x8,
                Keycode::D => 0x9,
                Keycode::F => 0xe,
                Keycode::Z => 0xa,
                Keycode::X => 0x0,
                Keycode::C => 0xb,
                Keycode::V => 0xf,
                _ => return None,
            })
        }

        for event in events.poll_iter() {
            match event {
                Event::Quit { .. }
                | Event::KeyDown {
                    keycode: Some(Keycode::ESCAPE),
                    ..
                } => self.is_running = false,
                Event::KeyDown {
                    keycode: Some(keycode),
                    ..
                } => {
                    if let Some(input) = keycode_to_input(keycode) {
                        self.input[input] = true;
                    } else {
                        match keycode {
                            Keycode::H => self.print_registers(),
                            Keycode::P => {
                                if self.is_suspended {
                                    println!("Resuming...");
                                } else {
                                    println!("Suspending...");
                                }
                                self.is_suspended = !self.is_suspended;
                            }
                            _ => {}
                        }
                    }
                }
                Event::KeyUp {
                    keycode: Some(keycode),
                    ..
                } => {
                    if let Some(input) = keycode_to_input(keycode) {
                        self.input[input] = false;
                    }
                }
                _ => {}
            }
        }
    }

    fn draw(&self, canvas: &mut Canvas<sdl2::video::Window>) -> Result<(), String> {
        canvas.set_draw_color(BACKGROUND_COLOR);
        canvas.clear();
        canvas.set_draw_color(FOREGROUND_COLOR);
        canvas.set_scale(PIXEL_SIZE as f32, PIXEL_SIZE as f32)?;
        let points: Vec<_> = self
            .display_memory
            .iter()
            .enumerate()
            .flat_map(|(y, row)| {
                row.iter().enumerate().filter_map(move |(x, pixel)| {
                    if *pixel == PIXEL_ON {
                        Some(Point::new(x as i32, y as i32))
                    } else {
                        None
                    }
                })
            })
            .collect();
        canvas.draw_points(&points[..])?;
        canvas.present();
        Ok(())
    }

    fn scroll_display(&mut self, dx: i8, dy: i8) {
        let mut buf = [[PIXEL_OFF; DISPLAY_WIDTH]; DISPLAY_HEIGHT];
        for (y, row) in buf.iter_mut().enumerate() {
            for (x, pixel) in row.iter_mut().enumerate() {
                let (src_x, src_y) = (
                    x.wrapping_add_signed(dx as isize),
                    y.wrapping_add_signed(dy as isize),
                );
                *pixel = if src_x < DISPLAY_WIDTH && src_y < DISPLAY_HEIGHT {
                    self.display_memory[src_y][src_x]
                } else {
                    PIXEL_OFF
                };
            }
        }
        self.display_memory = buf;
    }

    fn frame_cycle(&mut self) {
        let opcode = self.fetch_opcode(self.pc);
        match Chip8::decode(opcode) {
            Ok(instruction) => self.execute(instruction),
            Err(DecodeError::InvalidSecondaryOpcode(code, secondary)) => panic!(
                "Invalid opcode 0x{:x} (first opcode: 0x{:x}, secondary opcode: 0x{:x})",
                opcode, code, secondary
            ),
        }
        self.pc += 2;
        self.tick += 1;
    }

    fn fetch_opcode(&self, addr: Addr) -> Opcode {
        let addr = addr as usize;
        ((self.memory[addr] as Addr) << u8::BITS) | self.memory[addr + 1] as Addr
    }

    fn decode(opcode: Opcode) -> Result<Instruction, DecodeError> {
        use Instruction as I;
        let code = get_bits(opcode, 12..16) as u8;
        let addr = get_bits(opcode, 0..12);
        let n = get_bits(opcode, 0..4) as u8;
        let x = get_bits(opcode, 8..12) as Reg;
        let y = get_bits(opcode, 4..8) as Reg;
        let byte = get_bits(opcode, 0..8) as u8;
        Ok(match code {
            0x0 => match y {
                0x0 => match n {
                    0x0 => I::Suspend,
                    _ => return Err(DecodeError::InvalidSecondaryOpcode(code, byte)),
                },
                0xc => I::ScrollDown(n),
                0xe => match n {
                    0x0 => I::Clear,
                    0xe => I::Return,
                    _ => return Err(DecodeError::InvalidSecondaryOpcode(code, byte)),
                },
                0xf => match n {
                    0xb => I::ScrollRight,
                    0xc => I::ScrollLeft,
                    0xd => I::ExitChip,
                    0xe => I::DisableExtendedScreen,
                    0xf => I::EnableExtendedScreen,
                    _ => return Err(DecodeError::InvalidSecondaryOpcode(code, byte)),
                },
                _ => return Err(DecodeError::InvalidSecondaryOpcode(code, byte)),
            },
            0x1 => I::Jump(addr),
            0x2 => I::Call(addr),
            0x3 => I::SkipIfEqual {
                x,
                v: Value::Immediate(byte),
            },
            0x4 => I::SkipIfNotEqual {
                x,
                v: Value::Immediate(byte),
            },
            0x5 => match n {
                0x0 => I::SkipIfEqual {
                    x,
                    v: Value::Register(y),
                },
                _ => return Err(DecodeError::InvalidSecondaryOpcode(code, byte)),
            },
            0x6 => I::Load {
                x,
                v: Value::Immediate(byte),
            },
            0x7 => I::Add {
                x,
                v: Value::Immediate(byte),
            },
            0x8 => match n {
                0x0 => I::Load {
                    x,
                    v: Value::Register(y),
                },
                0x1 => I::Or { x, y },
                0x2 => I::And { x, y },
                0x3 => I::Xor { x, y },
                0x4 => I::Add {
                    x,
                    v: Value::Register(y),
                },
                0x5 => I::Sub { x, y },
                0x6 => I::ShiftRight { x, y },
                0x7 => I::SubNegative { x, y },
                0xe => I::ShiftLeft { x, y },
                _ => return Err(DecodeError::InvalidSecondaryOpcode(code, byte)),
            },
            0x9 => match n {
                0x0 => I::SkipIfNotEqual {
                    x,
                    v: Value::Register(y),
                },
                _ => return Err(DecodeError::InvalidSecondaryOpcode(code, byte)),
            },
            0xa => I::LoadIndex(addr),
            0xb => I::JumpOffset(addr),
            0xc => I::Random { x, mask: byte },
            0xd => I::Draw { x, y, n },
            0xe => match byte {
                0x9e => I::SkipIfKeyPressed { x },
                0xa1 => I::SkipIfKeyNotPressed { x },
                _ => return Err(DecodeError::InvalidSecondaryOpcode(code, byte)),
            },
            0xf => match byte {
                0x07 => I::LoadDtIntoRegister { x },
                0x0a => I::LoadKeyPress { x },
                0x15 => I::LoadRegisterIntoDt { x },
                0x18 => I::LoadRegisterIntoSt { x },
                0x1e => I::AddIndex { x },
                0x29 => I::LoadDigitIndex { x },
                0x30 => I::LoadExtendedDigitIndex { x },
                0x33 => I::LoadBcd { x },
                0x55 => I::StoreRegisters { x },
                0x65 => I::LoadRegisters { x },
                0x75 => I::StoreRegistersRPL { x },
                0x85 => I::LoadRegistersRPL { x },
                _ => return Err(DecodeError::InvalidSecondaryOpcode(code, byte)),
            },
            _ => unreachable!("All 16-bit values are accounted for"),
        })
    }

    fn execute(&mut self, instruction: Instruction) {
        use Instruction as I;
        match instruction {
            I::Suspend => self.is_suspended = true,
            I::ScrollDown(n) => self.scroll_display(0, n as i8),
            I::Clear => self.display_memory = [[0x0; DISPLAY_WIDTH]; DISPLAY_HEIGHT],
            I::Return => self.ret(),
            I::ScrollRight => self.scroll_display(4, 0),
            I::ScrollLeft => self.scroll_display(-4, 0),
            I::ExitChip => self.is_running = false,
            I::DisableExtendedScreen => self.is_in_extended_mode = false,
            I::EnableExtendedScreen => self.is_in_extended_mode = true,
            I::Jump(addr) => self.jump(addr),
            I::Call(addr) => self.call(addr),
            I::SkipIfEqual { x, v } => {
                if self.reg(x) == self.value(v) {
                    self.skip();
                }
            }
            I::SkipIfNotEqual { x, v } => {
                if self.reg(x) != self.value(v) {
                    self.skip();
                }
            }
            I::Load { x, v } => *self.reg_mut(x) = self.value(v),
            I::Add { x, v } => {
                let (lhs, rhs) = (self.reg(x), self.value(v));
                self.set_reg(x, lhs.wrapping_add(rhs));
                self.set_flag((lhs as u16 + rhs as u16 > u8::MAX as u16) as u8);
            }
            I::Or { x, y } => {
                *self.reg_mut(x) |= self.reg(y);
                if self.quirks.vf_reset {
                    self.set_flag(0);
                }
            }
            I::And { x, y } => {
                *self.reg_mut(x) &= self.reg(y);
                if self.quirks.vf_reset {
                    self.set_flag(0);
                }
            }
            I::Xor { x, y } => {
                *self.reg_mut(x) ^= self.reg(y);
                if self.quirks.vf_reset {
                    self.set_flag(0);
                }
            }
            I::Sub { x, y } => {
                let (lhs, rhs) = (self.reg(x), self.reg(y));
                self.set_reg(x, lhs.wrapping_sub(rhs));
                self.set_flag((lhs >= rhs) as u8);
            }
            I::ShiftRight { x, y } => {
                let lhs = if self.quirks.shifting {
                    self.reg(x)
                } else {
                    self.reg(y)
                };
                self.set_reg(x, lhs >> 1);
                self.set_flag((lhs & 0x1 != 0) as u8);
            }
            I::SubNegative { x, y } => {
                let (lhs, rhs) = (self.reg(x), self.reg(y));
                self.set_reg(x, rhs.wrapping_sub(lhs));
                self.set_flag((rhs >= lhs) as u8);
            }
            I::ShiftLeft { x, y } => {
                let lhs = if self.quirks.shifting {
                    self.reg(x)
                } else {
                    self.reg(y)
                };
                self.set_reg(x, lhs << 1);
                self.set_flag((lhs & (0x1 << 7) != 0) as u8);
            }
            I::LoadIndex(addr) => self.ir = addr,
            I::JumpOffset(addr) => {
                let x = if self.quirks.jumping {
                    get_bits(addr, 8..12) as u8
                } else {
                    0x0
                };
                self.jump(self.reg(x) as u16 + addr);
            }
            I::Random { x, mask } => {
                let mut buf = [0];
                self.rng.fill(&mut buf);
                self.rand = buf[0];
                self.set_reg(x, self.rand & mask);
            }
            I::Draw { x, y, n } => {
                let (x, y) = (self.reg(x), self.reg(y));
                let (mut sprite, width) = if n == 0 {
                    (vec![0x0; 32], 2)
                } else {
                    (vec![0x0; n as usize], 1)
                };
                let (ir, len) = (self.ir as usize, sprite.len());
                sprite.copy_from_slice(&self.memory[ir..ir + len]);
                self.draw_sprite(x, y, &sprite, width);
            }
            I::SkipIfKeyPressed { x } => {
                if self.is_key_down(self.reg(x)) {
                    self.skip();
                }
            }
            I::SkipIfKeyNotPressed { x } => {
                if !self.is_key_down(self.reg(x)) {
                    self.skip();
                }
            }
            I::LoadDtIntoRegister { x } => self.set_reg(x, self.dt),
            I::LoadKeyPress { x } => {
                for (i, key) in self.input.iter().enumerate() {
                    if *key {
                        self.set_reg(x, i as u8);
                        return;
                    }
                }
                self.pc -= 2;
            }
            I::LoadRegisterIntoDt { x } => self.dt = self.reg(x),
            I::LoadRegisterIntoSt { x } => self.st = self.reg(x),
            I::AddIndex { x } => self.ir += self.reg(x) as u16,
            I::LoadDigitIndex { x } => self.ir = FONTSET_ADDR + self.reg(x) as u16 * 5,
            I::LoadExtendedDigitIndex { x: _ } => todo!(),
            I::LoadBcd { x } => {
                let vx = self.reg(x);
                let idx = self.ir as usize;
                self.memory[idx] = vx / 100;
                self.memory[idx + 1] = (vx / 10) % 10;
                self.memory[idx + 2] = vx % 10;
            }
            I::StoreRegisters { x } => {
                let x = x as usize + 1;
                let idx = self.ir as usize;
                self.memory[idx..idx + x].copy_from_slice(&self.registers[..x]);
                if self.quirks.memory {
                    self.ir += x as u16;
                }
            }
            I::LoadRegisters { x } => {
                let x = x as usize + 1;
                let idx = self.ir as usize;
                self.registers[..x].copy_from_slice(&self.memory[idx..idx + x]);
                if self.quirks.memory {
                    self.ir += x as u16;
                }
            }
            I::StoreRegistersRPL { x } => {
                let x = x as usize + 1;
                self.rpl[..x].copy_from_slice(&self.registers[..x]);
            }
            I::LoadRegistersRPL { x } => {
                let x = x as usize + 1;
                self.registers[..x].copy_from_slice(&self.rpl[..x]);
            }
        }
    }

    fn push(&mut self, addr: Addr) {
        self.stack[self.sp as usize] = addr;
        self.sp += 1;
    }

    fn pop(&mut self) -> Addr {
        self.sp -= 1;
        self.stack[self.sp as usize]
    }

    fn value(&self, v: Value) -> u8 {
        match v {
            Value::Register(x) => self.reg(x),
            Value::Immediate(v) => v,
        }
    }

    fn reg(&self, r: Reg) -> u8 {
        self.registers[r as usize]
    }

    fn reg_mut(&mut self, r: Reg) -> &mut u8 {
        &mut self.registers[r as usize]
    }

    fn set_reg(&mut self, r: Reg, value: u8) {
        *self.reg_mut(r) = value;
    }

    fn set_flag(&mut self, value: u8) {
        *self.reg_mut(0xf) = value;
    }

    fn jump(&mut self, addr: Addr) {
        self.pc = addr - 2;
    }

    fn call(&mut self, addr: Addr) {
        self.push(self.pc + 2);
        self.jump(addr);
    }

    fn ret(&mut self) {
        let ret = self.pop();
        self.jump(ret);
    }

    fn skip(&mut self) {
        self.pc += 2;
    }

    fn display_width(&self) -> usize {
        if self.is_in_extended_mode {
            DISPLAY_WIDTH
        } else {
            DISPLAY_WIDTH / 2
        }
    }

    fn display_height(&self) -> usize {
        if self.is_in_extended_mode {
            DISPLAY_HEIGHT
        } else {
            DISPLAY_HEIGHT / 2
        }
    }

    fn draw_sprite(&mut self, x: u8, y: u8, sprite: &[u8], width: usize) {
        self.set_flag(0x0);
        let (x, y) = (
            x as usize % self.display_width(),
            y as usize % self.display_height(),
        );
        let mut collided_rows = Vec::new();
        for i in 0..sprite.len() * 8 {
            let bit_index = 8 - (i % 8) - 1;
            let byte_index = i / 8;
            let (dx, dy) = (i % (width * 8), i / (width * 8));
            let (cur_x, cur_y) = if self.quirks.clipping {
                (x + dx, y + dy)
            } else {
                (
                    (x + dx) % self.display_width(),
                    (y + dy) % self.display_height(),
                )
            };
            if cur_y >= self.display_height() {
                if !collided_rows.contains(&dy) {
                    collided_rows.push(dy);
                }
                continue;
            }
            if cur_x >= self.display_width() {
                continue;
            }
            let pixel = sprite[byte_index] & (0x1 << bit_index) != 0;
            if pixel {
                if self.get_pixel(cur_x, cur_y) == PIXEL_ON && !collided_rows.contains(&dy) {
                    collided_rows.push(dy);
                }
                self.draw_pixel(cur_x, cur_y);
            }
        }
        if self.is_in_extended_mode {
            self.set_flag(collided_rows.len() as u8);
        } else {
            self.set_flag((!collided_rows.is_empty()) as u8);
        }
    }

    fn get_pixel(&self, x: usize, y: usize) -> u32 {
        let (x, y) = if self.is_in_extended_mode {
            (x, y)
        } else {
            (x * 2, y * 2)
        };
        self.display_memory[y][x]
    }

    fn draw_pixel(&mut self, x: usize, y: usize) {
        let (x, y) = if self.is_in_extended_mode {
            (x, y)
        } else {
            /* If in low-res mode, pixels are 2x2 and coordinates for drawing are doubled */
            (x * 2, y * 2)
        };
        self.display_memory[y][x] ^= PIXEL_ON;
        if !self.is_in_extended_mode {
            self.display_memory[y + 1][x] ^= PIXEL_ON;
            self.display_memory[y][x + 1] ^= PIXEL_ON;
            self.display_memory[y + 1][x + 1] ^= PIXEL_ON;
        }
    }

    fn is_key_down(&self, key: u8) -> bool {
        if let Some(down) = self.input.get(key as usize) {
            *down
        } else {
            false
        }
    }

    fn print_registers(&self) {
        println!("\nPC: 0x{:0>3x}, IR: 0x{:0>3x}", self.pc, self.ir);
        println!(
            "V0: 0x{:0>2x}, V1: 0x{:0>2x}, V2: 0x{:0>2x}, V3: 0x{:0>2x}",
            self.reg(0x0),
            self.reg(0x1),
            self.reg(0x2),
            self.reg(0x3)
        );
        println!(
            "V4: 0x{:0>2x}, V5: 0x{:0>2x}, V6: 0x{:0>2x}, V7: 0x{:0>2x}",
            self.reg(0x4),
            self.reg(0x5),
            self.reg(0x6),
            self.reg(0x7)
        );
        println!(
            "V8: 0x{:0>2x}, V9: 0x{:0>2x}, VA: 0x{:0>2x}, VB: 0x{:0>2x}",
            self.reg(0x8),
            self.reg(0x9),
            self.reg(0xa),
            self.reg(0xb)
        );
        println!(
            "VC: 0x{:0>2x}, VD: 0x{:0>2x}, VE: 0x{:0>2x}, VF: 0x{:0>2x}",
            self.reg(0xc),
            self.reg(0xd),
            self.reg(0xe),
            self.reg(0xf)
        );
        println!(
            "SP: 0x{:0>2x}, DT: 0x{:0>2x}, ST: 0x{:0>2x}",
            self.sp, self.dt, self.st
        );
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_bitmask() {
        assert_eq!(bitmask(0..5), 0b00011111);
        assert_eq!(bitmask(1..6), 0b00111110);
        assert_eq!(bitmask(3..13), 0b1111111111000);
        assert_eq!(bitmask(0..16), 0b1111111111111111);
    }

    #[test]
    fn test_get_bits() {
        let v = 0b1111000011110000;

        assert_eq!(get_bits(v, 0..5), 0b10000);
        assert_eq!(get_bits(v, 2..6), 0b1100);
        assert_eq!(get_bits(v, 0..8), 0b11110000);
        assert_eq!(get_bits(v, 8..16), 0b11110000);
    }
}
