use std::{fs, ops::Range, path::Path, time::Instant};

use rand::{Rng, SeedableRng, rngs::SmallRng};

const REGISTERS_LEN: usize = 16;
const MEM_LEN: usize = 0x1000;
const STACK_LEN: usize = 16;
const FONTSET_ADDR: Addr = 0x050;
const FONTSET_LEN: usize = 0x50;
const FONTSET: [u8; FONTSET_LEN] = [
    0xf0, 0x90, 0x90, 0x90, 0xf0, /* 0 */
    0x20, 0x60, 0x20, 0x20, 0x70, /* 1 */
    0xf0, 0x10, 0xf0, 0x80, 0xf0, /* 2 */
    0xf0, 0x10, 0xf0, 0x10, 0xf0, /* 3 */
    0x90, 0x90, 0xf0, 0x10, 0x10, /* 4 */
    0xf0, 0x80, 0xf0, 0x10, 0xf0, /* 5 */
    0xf0, 0x80, 0xf0, 0x90, 0xf0, /* 6 */
    0xf0, 0x10, 0x20, 0x40, 0x40, /* 7 */
    0xf0, 0x90, 0xf0, 0x90, 0xf0, /* 8 */
    0xf0, 0x90, 0xf0, 0x10, 0xf0, /* 9 */
    0xf0, 0x90, 0xf0, 0x90, 0x90, /* A */
    0xe0, 0x90, 0xe0, 0x90, 0xe0, /* B */
    0xf0, 0x80, 0x80, 0x80, 0xf0, /* C */
    0xe0, 0x90, 0x90, 0x90, 0xe0, /* D */
    0xf0, 0x80, 0xf0, 0x80, 0xf0, /* E */
    0xf0, 0x80, 0xf0, 0x80, 0x80, /* F */
];
const INPUT_KEYS_LEN: usize = 16;

const DISPLAY_WIDTH: usize = 64;
const DISPLAY_HEIGHT: usize = 32;
const PIXEL_ON: u32 = 0xffffffff;
const PIXEL_OFF: u32 = 0x00000000;

const START_ADDR: Addr = 0x200;

type Addr = u16;
type Reg = u8;
type Opcode = u16;

pub enum Value {
    Register(Reg),
    Immediate(u8),
}

pub struct Chip8 {
    registers: [u8; REGISTERS_LEN],
    memory: [u8; MEM_LEN],
    /** Index Register. Stores an index into memory. */
    ir: Addr,

    /** Program Counter. Stores address of currently executing instruction in memory. */
    pc: Addr,

    /** Call Stack. Stores return addresses of CALL instructions. */
    stack: [Addr; STACK_LEN],

    /** Stack Pointer. Stores index of current return address in the call stack. */
    sp: u8,

    /** Delay Timer. If not zero, decrements by one each clock cycle. */
    dt: u8,

    /** Sound Timer. Behaves the same as delay timer, but a single note will buzz when non-zero. */
    st: u8,

    /** Input Keys. Stores whether each of the 16 input keys is pressed or not pressed. */
    input: [bool; 16],

    /** Monochrome Display Memory. A memory buffer storing the graphics to display. */
    mdm: [[u32; DISPLAY_WIDTH]; DISPLAY_HEIGHT],

    /** Random Number Generator. Generates random numbers. */
    rng: SmallRng,

    /** Random Byte. The current random byte generated by the random number generator. */
    rand: u8,

    /** Instruction Table. Table used for decoding opcodes. */
    i_table: Vec<Vec<Option<Instruction>>>,
}

pub enum Chip8Error {
    IndexOutOfRange(usize),
}

/**
 * Vx means `registers[x]`
 */
pub enum Instruction {
    /** Clear the screen. */
    Cls,

    /** Return from a subroutine. */
    Ret,

    /** Jump to location `addr`. */
    Jp(Addr),

    /** Call subroutine at `addr`. */
    Call(Addr),

    /** Skip next instruction if `Vx == v`. */
    Se { x: Reg, v: Value },

    /** Skip next instruction if `Vx != v`. */
    Sne { x: Reg, v: Value },

    /** Set value of `Vx` to `v`. */
    Ld { x: Reg, v: Value },

    /** Set value of `Vx` to `Vx + v`. Set `Vf = 1` if `v` is a register and `Vx + v > 255`. */
    Add { x: Reg, v: Value },

    /** Set value of `Vx` to `Vx | Vy`. */
    Or { x: Reg, y: Reg },

    /** Set value of `Vx` to `Vx & Vy`. */
    And { x: Reg, y: Reg },

    /** Set value of `Vx` to `Vx ^ Vy`. */
    Xor { x: Reg, y: Reg },

    /** Set `Vf = 1` if `Vx > Vy`. Then set value of `Vx` to `Vx - Vy`. */
    Sub { x: Reg, y: Reg },

    /** Set `Vf = 1` if least significant bit of `Vx` is one. Then set value of `Vx` to `Vx >> 1`. */
    Shr { x: Reg, y: Option<Reg> },

    /** Set `Vf = 1` if `Vy > Vx`. Then set value of `Vx` to `Vx - Vy`. */
    Subn { x: Reg, y: Reg },

    /**  Set `Vf = 1` if most significant bit of `Vx` is one. Then set value of `Vx` to `Vx << 1`. */
    Shl { x: Reg, y: Option<Reg> },

    /** Set register `I` to `addr`. */
    Ldi(Addr),

    /** Jump to location `addr + V0`. */
    Jpv0(Addr),

    /** Set `Vx` to a newly generated random byte ANDed with `mask`. */
    Rnd { x: Reg, mask: u8 },

    /** Display an n-byte sprite starting at location `I` at `(Vx, Vy)`. Set `Vf = collision`. */
    Drw { x: Reg, y: Reg, n: u8 },

    /** Skip next instruction if key with the value in `Vx` is pressed. */
    Skp { x: Reg },

    /** Skip next instruction if key with the value in `Vx` is NOT pressed. */
    Sknp { x: Reg },

    /** Set `Vx = DT`. */
    Ldrdt { x: Reg },

    /** Wait for a key press, then store value of key in `Vx`. */
    Ldk { x: Reg },

    /** Set `DT = Vx`. */
    Lddtr { x: Reg },

    /** Set `ST = Vx`. */
    Ldstr { x: Reg },

    /** Set `I` to `I + Vx`. */
    Addi { x: Reg },

    /** Set `I` to location of digit sprite corresponding to value in `Vx`. */
    Ldf { x: Reg },

    /** Store BCD representation of `Vx` in location `I`, `I+1` and `I+2`. */
    Ldb { x: Reg },

    /** Store `V0` to `Vx` in memory, starting at location `I`. */
    Strs { x: Reg },

    /** Read registers `V0` to `Vx` from memory starting at location `I`. */
    Ldrs { x: Reg },
}

fn bitmask(bits: Range<u16>) -> u16 {
    let range = Range {
        start: bits.start,
        end: bits.end.min(16)
    };
    range.reduce(|acc, i| acc | (0x1 << i)).unwrap_or(0)
}

fn get_bits(value: u16, bits: Range<u16>) -> u16 {
    let start = bits.start;
    (value & bitmask(bits)) >> start
}

impl Chip8 {
    pub fn new() -> Self {
        let mut memory = [0; MEM_LEN];

        for (dst, src) in memory[FONTSET_ADDR as usize..].iter_mut().zip(FONTSET) {
            *dst = src;
        }

        let mut rng = SmallRng::seed_from_u64(Instant::now().elapsed().as_secs());
        let rand = rng.random_range(0x0..=u8::MAX);

        Self {
            registers: [0; REGISTERS_LEN],
            memory,
            ir: 0x0,
            pc: START_ADDR,
            stack: [0x0; STACK_LEN],
            sp: 0x0,
            dt: 0x0,
            st: 0x0,
            input: [false; INPUT_KEYS_LEN],
            mdm: [[PIXEL_OFF; DISPLAY_WIDTH]; DISPLAY_HEIGHT],
            rng,
            rand,
            i_table: Chip8::generate_i_table(),
        }
    }

    pub fn load_rom<P>(&mut self, filepath: &P) -> Result<(), Chip8Error>
    where
        P: AsRef<Path>,
    {
        self.load(
            &fs::read(filepath).expect("couldn't open ROM file"),
            START_ADDR,
        )?;
        Ok(())
    }

    fn load(&mut self, bytes: &[u8], addr: Addr) -> Result<(), Chip8Error> {
        let addr = addr as usize;
        if addr + bytes.len() > self.memory.len() {
            return Err(Chip8Error::IndexOutOfRange(addr + bytes.len() - 1));
        }
        for (dst, src) in self.memory[addr..].iter_mut().zip(bytes) {
            *dst = *src;
        }
        Ok(())
    }

    fn cycle(&mut self) {
        let opcode = self.fetch_opcode(self.pc);
        let instruction = Chip8::decode(opcode);
        self.execute(instruction);
    }

    fn fetch_opcode(&self, addr: Addr) -> Opcode {
        let addr = addr as usize;
        (self.memory[addr] as Addr) << u8::BITS | self.memory[addr + 1] as Addr
    }

    fn decode(opcode: Opcode) -> Instruction {
        use Instruction as I;
        match get_bits(opcode, 12..16) {
            0x0 => match get_bits(opcode, 12..16) {},
            0x1 => I::Jp(get_bits(opcode, 0..12)),
            0x2 => ,
            0x3 => ,
            0x4 => ,
            0x5 => ,
            0x6 => ,
            0x7 => ,
            0x8 => ,
            0x9 => ,
            0xa => ,
            0xb => ,
            0xc => ,
            0xd => ,
            0xe => ,
            0xf => ,

        }
    }

    fn generate_i_table() -> Vec<Vec<Option<Instruction>>> {
        let mut table = vec![]
    }

    fn execute(&mut self, instruction: Instruction) {
        use Instruction as I;
        match instruction {
            I::Cls => self.mdm = [[0x0; DISPLAY_WIDTH]; DISPLAY_HEIGHT],
            I::Ret => self.ret(),
            I::Jp(addr) => self.jump(addr),
            I::Call(addr) => self.call(addr),
            I::Se { x, v } => {
                if self.reg(x) == self.value(v) {
                    self.skip();
                }
            }
            I::Sne { x, v } => {
                if self.reg(x) != self.value(v) {
                    self.skip();
                }
            }
            I::Ld { x, v } => *self.reg_mut(x) = self.value(v),
            I::Add { x, v } => *self.reg_mut(x) += self.value(v),
            I::Or { x, y } => *self.reg_mut(x) |= self.reg(y),
            I::And { x, y } => *self.reg_mut(x) &= self.reg(y),
            I::Xor { x, y } => *self.reg_mut(x) ^= self.reg(y),
            I::Sub { x, y } => {
                self.set_flag((self.reg(x) > self.reg(y)) as u8);
                self.set_reg(x, self.reg(x).wrapping_sub(self.reg(y)));
            }
            I::Shr { x, y: _ } => {
                self.set_flag((self.reg(x) & 0x1 != 0) as u8);
                *self.reg_mut(x) >>= 1;
            }
            I::Subn { x, y } => {
                self.set_flag((self.reg(y) > self.reg(x)) as u8);
                self.set_reg(x, self.reg(y).wrapping_sub(self.reg(x)));
            }
            I::Shl { x, y: _ } => {
                self.set_flag((self.reg(x) & (0x1 << 7) != 0) as u8);
                *self.reg_mut(x) <<= 1;
            }
            I::Ldi(addr) => self.ir = addr,
            I::Jpv0(addr) => self.pc = addr + self.reg(0x0) as u16,
            I::Rnd { x, mask } => {
                let mut buf = [0];
                self.rng.fill(&mut buf);
                self.rand = buf[0];
                self.set_reg(x, self.rand & mask);
            }
            I::Drw { x, y, n } => {
                let (x, y) = (self.reg(x), self.reg(y));
                let mut sprite = vec![0x0; n as usize];
                sprite
                    .copy_from_slice(&self.memory[self.ir as usize..(self.ir + n as u16) as usize]);
                self.draw_sprite(x, y, &sprite);
            }
            I::Skp { x } => {
                if self.is_key_down(self.reg(x)) {
                    self.skip();
                }
            }
            I::Sknp { x } => {
                if !self.is_key_down(self.reg(x)) {
                    self.skip();
                }
            }
            I::Ldrdt { x } => self.set_reg(x, self.dt),
            I::Ldk { x: _ } => todo!(),
            I::Lddtr { x } => self.dt = self.reg(x),
            I::Ldstr { x } => self.st = self.reg(x),
            I::Addi { x } => self.ir += self.reg(x) as u16,
            I::Ldf { x } => self.ir = FONTSET_ADDR + self.reg(x) as u16 * 5,
            I::Ldb { x } => {
                let vx = self.reg(x);
                let idx = self.ir as usize;
                self.memory[idx] = vx / 100;
                self.memory[idx + 1] = (vx / 10) % 10;
                self.memory[idx + 1] = vx % 10;
            }

            I::Strs { x } => {
                let x = x as usize;
                let idx = self.ir as usize;
                self.memory[idx..idx + x].copy_from_slice(&self.registers[0..x]);
            }
            I::Ldrs { x } => {
                let x = x as usize;
                let idx = self.ir as usize;
                self.registers[0..x].copy_from_slice(&self.memory[idx..idx + x]);
            }
        }
    }

    fn push(&mut self, addr: Addr) {
        self.stack[self.sp as usize] = addr;
        self.sp += 1;
    }

    fn pop(&mut self) -> Addr {
        self.sp -= 1;
        self.stack[self.sp as usize]
    }

    fn value(&self, v: Value) -> u8 {
        match v {
            Value::Register(x) => self.reg(x),
            Value::Immediate(v) => v,
        }
    }

    fn reg(&self, r: Reg) -> u8 {
        self.registers[r as usize]
    }

    fn reg_mut(&mut self, r: Reg) -> &mut u8 {
        &mut self.registers[r as usize]
    }

    fn set_reg(&mut self, r: Reg, value: u8) {
        *self.reg_mut(r) = value;
    }

    fn set_flag(&mut self, value: u8) {
        *self.reg_mut(0xf) = value;
    }

    fn jump(&mut self, addr: Addr) {
        self.pc = addr;
    }

    fn call(&mut self, addr: Addr) {
        self.push(self.pc + 2);
        self.jump(addr);
    }

    fn ret(&mut self) {
        let ret = self.pop();
        self.jump(ret);
    }

    fn skip(&mut self) {
        self.pc += 2;
    }

    fn draw_sprite(&mut self, x: u8, y: u8, sprite: &[u8]) {
        self.set_flag(0x0);
        for (dy, row) in sprite.iter().enumerate() {
            for dx in 0..8 {
                let (cur_x, cur_y) = (
                    x.wrapping_add(dx) as usize,
                    y.wrapping_add(dy as u8) as usize,
                );
                let pixel = row & (0x1 << (7 - dx)) != 0;
                if pixel {
                    if self.mdm[cur_y][cur_x] == PIXEL_ON {
                        self.set_flag(0x1);
                    }
                    self.mdm[cur_y][cur_x] ^= self.mdm[cur_y][cur_x];
                }
            }
        }
    }

    fn is_key_down(&self, key: u8) -> bool {
        if let Some(down) = self.input.get(key as usize) {
            *down
        } else {
            false
        }
    }
}
