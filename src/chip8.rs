use std::{fs, io, path::Path, time::Instant};

use rand::{
    Rng, SeedableRng,
    rngs::{SmallRng, ThreadRng},
};

const REGISTERS_LEN: usize = 16;
const MEM_LEN: usize = 0x1000;
const STACK_LEN: usize = 16;
const FONTSET_ADDR: usize = 0x050;
const FONTSET_LEN: usize = 0x50;
const FONTSET: [u8; FONTSET_LEN] = [
    0xf0, 0x90, 0x90, 0x90, 0xf0, /* 0 */
    0x20, 0x60, 0x20, 0x20, 0x70, /* 1 */
    0xf0, 0x10, 0xf0, 0x80, 0xf0, /* 2 */
    0xf0, 0x10, 0xf0, 0x10, 0xf0, /* 3 */
    0x90, 0x90, 0xf0, 0x10, 0x10, /* 4 */
    0xf0, 0x80, 0xf0, 0x10, 0xf0, /* 5 */
    0xf0, 0x80, 0xf0, 0x90, 0xf0, /* 6 */
    0xf0, 0x10, 0x20, 0x40, 0x40, /* 7 */
    0xf0, 0x90, 0xf0, 0x90, 0xf0, /* 8 */
    0xf0, 0x90, 0xf0, 0x10, 0xf0, /* 9 */
    0xf0, 0x90, 0xf0, 0x90, 0x90, /* A */
    0xe0, 0x90, 0xe0, 0x90, 0xe0, /* B */
    0xf0, 0x80, 0x80, 0x80, 0xf0, /* C */
    0xe0, 0x90, 0x90, 0x90, 0xe0, /* D */
    0xf0, 0x80, 0xf0, 0x80, 0xf0, /* E */
    0xf0, 0x80, 0xf0, 0x80, 0x80, /* F */
];
const INPUT_KEYS_LEN: usize = 16;

const DISPLAY_WIDTH: usize = 64;
const DISPLAY_HEIGHT: usize = 32;
const PIXEL_ON: u32 = 0xffffffff;
const PIXEL_OFF: u32 = 0x00000000;

const START_ADDR: usize = 0x200;

pub struct Chip8 {
    registers: [u8; REGISTERS_LEN],
    memory: [u8; MEM_LEN],
    /** Index Register. Stores an index into memory. */
    ir: u16,

    /** Program Counter. Stores address of currently executing instruction in memory. */
    pc: u16,

    /** Call Stack. Stores return addresses of CALL instructions. */
    stack: [u16; STACK_LEN],

    /** Stack Pointer. Stores index of current return address in the call stack. */
    sp: u8,

    /** Delay Timer. If not zero, decrements by one each clock cycle. */
    dt: u8,

    /** Sound Timer. Behaves the same as delay timer, but a single note will buzz when non-zero. */
    st: u8,

    /** Input Keys. Stores whether each of the 16 input keys is pressed or not pressed. */
    input: [bool; 16],

    /** Monochrome Display Memory. A memory buffer storing the graphics to display. */
    mdm: [[u32; DISPLAY_WIDTH]; DISPLAY_HEIGHT],

    /** Random Number Generator. Generates random numbers. */
    rng: SmallRng,

    /** Random Byte. The current random byte generated by the random number generator. */
    rand: u8,
}

pub enum Chip8Error {
    IndexOutOfRange(usize),
}

type Addr = u16;
type Reg = u8;

pub enum Value {
    Register(Reg),
    Immediate(u8),
}

/**
 * Vx means `registers[x]`
 */
pub enum Instruction {
    /** Clear the screen. */
    Cls,

    /** Return from a subroutine. */
    Ret,

    /** Jump to location `addr`. */
    Jp(Addr),

    /** Call subroutine at `addr`. */
    Call(Addr),

    /** Skip next instruction if `Vx == v`. */
    Se { x: Reg, v: Value },

    /** Skip next instruction if `Vx != v`. */
    Sne { x: Reg, v: Value },

    /** Set value of `Vx` to `v`. */
    Ld { x: Reg, v: Value },

    /** Set value of `Vx` to `Vx + v`. Set `Vf = 1` if `v` is a register and `Vx + v > 255`. */
    Add { x: Reg, v: Value },

    /** Set value of `Vx` to `Vx | Vy`. */
    Or { x: Reg, y: Reg },

    /** Set value of `Vx` to `Vx & Vy`. */
    And { x: Reg, y: Reg },

    /** Set value of `Vx` to `Vx ^ Vy`. */
    Xor { x: Reg, y: Reg },

    /** Set `Vf = 1` if `Vx > Vy`. Then set value of `Vx` to `Vx - Vy`. */
    Sub { x: Reg, y: Reg },

    /** Set `Vf = 1` if least significant bit of `Vx` is one. Then set value of `Vx` to `Vx >> 1`. */
    Shr { x: Reg, y: Option<Reg> },

    /** Set `Vf = 1` if `Vy > Vx`. Then set value of `Vx` to `Vx - Vy`. */
    Subn { x: Reg, y: Reg },

    /**  Set `Vf = 1` if most significant bit of `Vx` is one. Then set value of `Vx` to `Vx << 1`. */
    Shl { x: Reg, y: Option<Reg> },

    /** Set register `I` to `addr`. */
    Ldi(Addr),

    /** Jump to location `addr + V0`. */
    Jpv0(Addr),

    /** Set `Vx` to a newly generated random byte ANDed with `mask`. */
    Rnd { x: Reg, mask: u8 },

    /** Display an n-byte sprite starting at location `I` at `(Vx, Vy)`. Set `Vf = collision`. */
    Drw { x: Reg, y: Reg, n: u8 },

    /** Skip next instruction if key with the value in `Vx` is pressed. */
    Skp { x: Reg },

    /** Skip next instruction if key with the value in `Vx` is NOT pressed. */
    Sknp { x: Reg },

    /** Set `Vx = DT`. */
    Ldrdt { x: Reg },

    /** Wait for a key press, then store value of key in `Vx`. */
    Ldk { x: Reg },

    /** Set `DT = Vx`. */
    Lddtr { x: Reg },

    /** Set `ST = Vx`. */
    Ldstr { x: Reg },

    /** Set `I` to `I + Vx`. */
    Addi { x: Reg },

    /** Set `I` to location of digit sprite corresponding to value in `Vx`. */
    Ldf { x: Reg },

    /** Store BCD representation of `Vx` in location `I`, `I+1` and `I+2`. */
    Ldb { x: Reg },

    /** Store `V0` to `Vx` in memory, starting at location `I`. */
    Strs { x: Reg },

    /** Read registers `V0` to `Vx` from memory starting at location `I`. */
    Ldrs { x: Reg },
}

impl Chip8 {
    pub fn new() -> Self {
        let mut memory = [0; MEM_LEN];

        for (dst, src) in memory[FONTSET_ADDR..].iter_mut().zip(FONTSET) {
            *dst = src;
        }

        let mut rng = SmallRng::seed_from_u64(Instant::now().elapsed().as_secs());
        let rand = rng.random_range(0x0..=u8::MAX);

        Self {
            registers: [0; REGISTERS_LEN],
            memory,
            ir: 0x0,
            pc: START_ADDR as u16,
            stack: [0x0; STACK_LEN],
            sp: 0x0,
            dt: 0x0,
            st: 0x0,
            input: [false; INPUT_KEYS_LEN],
            mdm: [[PIXEL_OFF; DISPLAY_WIDTH]; DISPLAY_HEIGHT],
            rng,
            rand,
        }
    }

    pub fn load_rom<P>(&mut self, filepath: &P) -> Result<(), Chip8Error>
    where
        P: AsRef<Path>,
    {
        self.load(
            &fs::read(filepath).expect("couldn't open ROM file"),
            START_ADDR,
        )?;
        Ok(())
    }

    fn load(&mut self, bytes: &[u8], addr: usize) -> Result<(), Chip8Error> {
        if addr + bytes.len() > self.memory.len() {
            return Err(Chip8Error::IndexOutOfRange(addr + bytes.len() - 1));
        }
        for (dst, src) in self.memory[addr..].iter_mut().zip(bytes) {
            *dst = *src;
        }
        Ok(())
    }
}
