use core::panic;
use std::{
    fs,
    ops::Range,
    path::Path,
    thread,
    time::{Duration, Instant, SystemTime},
};

use rand::{Rng, SeedableRng, rngs::SmallRng};
use sdl2::{
    EventPump, event::Event, keyboard::Keycode, pixels::Color, rect::Point, render::Canvas,
};

const REGISTERS_LEN: usize = 16;
const MEM_LEN: usize = 0x1000;
const STACK_LEN: usize = 16;
const FONTSET_ADDR: Addr = 0x050;
const FONTSET_LEN: usize = 0x50;
const FONTSET: [u8; FONTSET_LEN] = [
    0xf0, 0x90, 0x90, 0x90, 0xf0, /* 0 */
    0x20, 0x60, 0x20, 0x20, 0x70, /* 1 */
    0xf0, 0x10, 0xf0, 0x80, 0xf0, /* 2 */
    0xf0, 0x10, 0xf0, 0x10, 0xf0, /* 3 */
    0x90, 0x90, 0xf0, 0x10, 0x10, /* 4 */
    0xf0, 0x80, 0xf0, 0x10, 0xf0, /* 5 */
    0xf0, 0x80, 0xf0, 0x90, 0xf0, /* 6 */
    0xf0, 0x10, 0x20, 0x40, 0x40, /* 7 */
    0xf0, 0x90, 0xf0, 0x90, 0xf0, /* 8 */
    0xf0, 0x90, 0xf0, 0x10, 0xf0, /* 9 */
    0xf0, 0x90, 0xf0, 0x90, 0x90, /* A */
    0xe0, 0x90, 0xe0, 0x90, 0xe0, /* B */
    0xf0, 0x80, 0x80, 0x80, 0xf0, /* C */
    0xe0, 0x90, 0x90, 0x90, 0xe0, /* D */
    0xf0, 0x80, 0xf0, 0x80, 0xf0, /* E */
    0xf0, 0x80, 0xf0, 0x80, 0x80, /* F */
];
const INPUT_KEYS_LEN: usize = 16;

const DISPLAY_WIDTH: usize = 64;
const DISPLAY_HEIGHT: usize = 32;
const PIXEL_ON: u32 = 0xffffffff;
const PIXEL_OFF: u32 = 0x00000000;
const PIXEL_SIZE: u32 = 10;

const START_ADDR: Addr = 0x200;

type Addr = u16;
type Reg = u8;
type Opcode = u16;

pub enum Value {
    Register(Reg),
    Immediate(u8),
}

#[derive(Debug)]
pub struct Chip8 {
    registers: [u8; REGISTERS_LEN],
    memory: [u8; MEM_LEN],
    /** Index Register. Stores an index into memory. */
    ir: Addr,

    /** Program Counter. Stores address of currently executing instruction in memory. */
    pc: Addr,

    /** Call Stack. Stores return addresses of CALL instructions. */
    stack: [Addr; STACK_LEN],

    /** Stack Pointer. Stores index of current return address in the call stack. */
    sp: u8,

    /** Delay Timer. If not zero, decrements by one each clock cycle. */
    dt: u8,

    /** Sound Timer. Behaves the same as delay timer, but a single note will buzz when non-zero. */
    st: u8,

    /** Input Keys. Stores whether each of the 16 input keys is pressed or not pressed. */
    input: [bool; 16],

    /** Monochrome Display Memory. A memory buffer storing the graphics to display. */
    display_memory: [[u32; DISPLAY_WIDTH]; DISPLAY_HEIGHT],

    /** Random Number Generator. Generates random numbers. */
    rng: SmallRng,

    /** Random Byte. The current random byte generated by the random number generator. */
    rand: u8,

    is_running: bool,
}

#[derive(Debug)]
pub enum Chip8Error {
    IndexOutOfRange(usize),
}

enum DecodeError {
    InvalidSecondaryOpcode(u8, u8),
}

/**
 * Vx means `registers[x]`
 */
pub enum Instruction {
    /** Clear the screen. */
    Cls,

    /** Return from a subroutine. */
    Ret,

    /** Jump to location `addr`. */
    Jp(Addr),

    /** Call subroutine at `addr`. */
    Call(Addr),

    /** Skip next instruction if `Vx == v`. */
    Se { x: Reg, v: Value },

    /** Skip next instruction if `Vx != v`. */
    Sne { x: Reg, v: Value },

    /** Set value of `Vx` to `v`. */
    Ld { x: Reg, v: Value },

    /** Set value of `Vx` to `Vx + v`. Set `Vf = 1` if `v` is a register and `Vx + v > 255`. */
    Add { x: Reg, v: Value },

    /** Set value of `Vx` to `Vx | Vy`. */
    Or { x: Reg, y: Reg },

    /** Set value of `Vx` to `Vx & Vy`. */
    And { x: Reg, y: Reg },

    /** Set value of `Vx` to `Vx ^ Vy`. */
    Xor { x: Reg, y: Reg },

    /** Set `Vf = 1` if `Vx > Vy`. Then set value of `Vx` to `Vx - Vy`. */
    Sub { x: Reg, y: Reg },

    /** Set `Vf = 1` if least significant bit of `Vx` is one. Then set value of `Vx` to `Vx >> 1`. */
    Shr { x: Reg, y: Option<Reg> },

    /** Set `Vf = 1` if `Vy > Vx`. Then set value of `Vx` to `Vx - Vy`. */
    Subn { x: Reg, y: Reg },

    /**  Set `Vf = 1` if most significant bit of `Vx` is one. Then set value of `Vx` to `Vx << 1`. */
    Shl { x: Reg, y: Option<Reg> },

    /** Set register `I` to `addr`. */
    Ldi(Addr),

    /** Jump to location `addr + V0`. */
    Jpv0(Addr),

    /** Set `Vx` to a newly generated random byte ANDed with `mask`. */
    Rnd { x: Reg, mask: u8 },

    /** Display an n-byte sprite starting at location `I` at `(Vx, Vy)`. Set `Vf = collision`. */
    Drw { x: Reg, y: Reg, n: u8 },

    /** Skip next instruction if key with the value in `Vx` is pressed. */
    Skp { x: Reg },

    /** Skip next instruction if key with the value in `Vx` is NOT pressed. */
    Sknp { x: Reg },

    /** Set `Vx = DT`. */
    Ldrdt { x: Reg },

    /** Wait for a key press, then store value of key in `Vx`. */
    Ldk { x: Reg },

    /** Set `DT = Vx`. */
    Lddtr { x: Reg },

    /** Set `ST = Vx`. */
    Ldstr { x: Reg },

    /** Set `I` to `I + Vx`. */
    Addi { x: Reg },

    /** Set `I` to location of digit sprite corresponding to value in `Vx`. */
    Ldf { x: Reg },

    /** Store BCD representation of `Vx` in location `I`, `I+1` and `I+2`. */
    Ldb { x: Reg },

    /** Store `V0` to `Vx` in memory, starting at location `I`. */
    Strs { x: Reg },

    /** Read registers `V0` to `Vx` from memory starting at location `I`. */
    Ldrs { x: Reg },
}

fn bitmask(bits: Range<u16>) -> u16 {
    let range = Range {
        start: bits.start,
        end: bits.end.min(16),
    };
    range.fold(0, |acc, i| acc | (0x1 << i))
}

fn get_bits(value: u16, bits: Range<u16>) -> u16 {
    let start = bits.start;
    (value & bitmask(bits)) >> start
}

impl Chip8 {
    pub fn new() -> Self {
        let mut memory = [0; MEM_LEN];

        for (dst, src) in memory[FONTSET_ADDR as usize..].iter_mut().zip(FONTSET) {
            *dst = src;
        }

        let mut rng = SmallRng::seed_from_u64(
            SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_secs(),
        );
        let rand = rng.random_range(0x0..=u8::MAX);

        Self {
            registers: [0; REGISTERS_LEN],
            memory,
            ir: 0x0,
            pc: START_ADDR,
            stack: [0x0; STACK_LEN],
            sp: 0x0,
            dt: 0x0,
            st: 0x0,
            input: [false; INPUT_KEYS_LEN],
            display_memory: [[PIXEL_OFF; DISPLAY_WIDTH]; DISPLAY_HEIGHT],
            rng,
            rand,
            is_running: false,
        }
    }

    pub fn load_rom<P>(&mut self, filepath: &P) -> Result<(), Chip8Error>
    where
        P: AsRef<Path> + ?Sized,
    {
        self.load(
            &fs::read(filepath).expect("couldn't open ROM file"),
            START_ADDR,
        )?;
        Ok(())
    }

    fn load(&mut self, bytes: &[u8], addr: Addr) -> Result<(), Chip8Error> {
        let addr = addr as usize;
        if addr + bytes.len() > self.memory.len() {
            return Err(Chip8Error::IndexOutOfRange(addr + bytes.len() - 1));
        }
        for (dst, src) in self.memory[addr..].iter_mut().zip(bytes) {
            *dst = *src;
        }
        Ok(())
    }

    pub fn run(&mut self) {
        let sdl_ctx = sdl2::init().unwrap();
        let video = sdl_ctx.video().unwrap();

        let width = DISPLAY_WIDTH as u32 * PIXEL_SIZE;
        let height = DISPLAY_HEIGHT as u32 * PIXEL_SIZE;
        let window = video
            .window("chip8 emulator", width, height)
            .position_centered()
            .build()
            .unwrap();

        let mut events = sdl_ctx.event_pump().unwrap();

        let mut canvas = window.into_canvas().build().unwrap();
        canvas.set_draw_color(Color::WHITE);
        canvas.clear();
        canvas.present();

        self.is_running = true;

        while self.is_running {
            let start = Instant::now();
            self.handle_events(&mut events);
            self.cycle();
            self.draw(&mut canvas).expect("rendering driver failed");
            let time_taken = Instant::now().duration_since(start);
            thread::sleep(Duration::from_micros(1000 / 60).saturating_sub(time_taken));
        }
    }

    fn handle_events(&mut self, events: &mut EventPump) {
        fn keycode_to_input(keycode: Keycode) -> Option<usize> {
            Some(match keycode {
                Keycode::NUM_1 => 0x1,
                Keycode::NUM_2 => 0x2,
                Keycode::NUM_3 => 0x3,
                Keycode::NUM_4 => 0xc,
                Keycode::Q => 0x4,
                Keycode::W => 0x5,
                Keycode::E => 0x6,
                Keycode::R => 0xd,
                Keycode::A => 0x7,
                Keycode::S => 0x8,
                Keycode::D => 0x9,
                Keycode::F => 0xe,
                Keycode::Z => 0xa,
                Keycode::X => 0x0,
                Keycode::C => 0xb,
                Keycode::V => 0xf,
                _ => return None,
            })
        }

        for event in events.poll_iter() {
            match event {
                Event::Quit { .. }
                | Event::KeyDown {
                    keycode: Some(Keycode::ESCAPE),
                    ..
                } => self.is_running = false,
                Event::KeyDown {
                    keycode: Some(keycode),
                    ..
                } => {
                    if let Some(input) = keycode_to_input(keycode) {
                        self.input[input] = true;
                    } else if keycode == Keycode::H {
                        println!("{:?}", self);
                    }
                }
                Event::KeyUp {
                    keycode: Some(keycode),
                    ..
                } => {
                    if let Some(input) = keycode_to_input(keycode) {
                        self.input[input] = false;
                    }
                }
                _ => {}
            }
        }
    }

    fn draw(&self, canvas: &mut Canvas<sdl2::video::Window>) -> Result<(), String> {
        canvas.set_draw_color(Color::WHITE);
        canvas.set_scale(PIXEL_SIZE as f32, PIXEL_SIZE as f32)?;
        let points: Vec<_> = self
            .display_memory
            .iter()
            .enumerate()
            .flat_map(|(y, row)| {
                row.iter().enumerate().filter_map(move |(x, pixel)| {
                    if *pixel == PIXEL_ON {
                        Some(Point::new(x as i32, y as i32))
                    } else {
                        None
                    }
                })
            })
            .collect();
        canvas.draw_points(&points[..])?;
        Ok(())
    }

    fn cycle(&mut self) {
        let opcode = self.fetch_opcode(self.pc);
        match Chip8::decode(opcode) {
            Ok(instruction) => self.execute(instruction),
            Err(DecodeError::InvalidSecondaryOpcode(code, secondary)) => panic!(
                "Invalid opcode 0x{:x} (first opcode: {:x}, secondary opcode: {:x})",
                opcode, code, secondary
            ),
        }
        self.pc += 2;
    }

    fn fetch_opcode(&self, addr: Addr) -> Opcode {
        let addr = addr as usize;
        ((self.memory[addr] as Addr) << u8::BITS) | self.memory[addr + 1] as Addr
    }

    fn decode(opcode: Opcode) -> Result<Instruction, DecodeError> {
        use Instruction as I;
        let code = get_bits(opcode, 12..16) as u8;
        let addr = get_bits(opcode, 0..12);
        let n = get_bits(opcode, 0..4) as u8;
        let x = get_bits(opcode, 8..12) as Reg;
        let y = get_bits(opcode, 4..8) as Reg;
        let byte = get_bits(opcode, 0..8) as u8;
        Ok(match code {
            0x0 => match byte {
                0xe0 => I::Cls,
                0xee => I::Ret,
                _ => return Err(DecodeError::InvalidSecondaryOpcode(code, byte)),
            },
            0x1 => I::Jp(addr),
            0x2 => I::Call(addr),
            0x3 => I::Se {
                x,
                v: Value::Immediate(byte),
            },
            0x4 => I::Sne {
                x,
                v: Value::Immediate(byte),
            },
            0x5 => match n {
                0x0 => I::Se {
                    x,
                    v: Value::Register(y),
                },
                _ => return Err(DecodeError::InvalidSecondaryOpcode(code, byte)),
            },
            0x6 => I::Ld {
                x,
                v: Value::Immediate(byte),
            },
            0x7 => I::Add {
                x,
                v: Value::Immediate(byte),
            },
            0x8 => match n {
                0x0 => I::Ld {
                    x,
                    v: Value::Register(y),
                },
                0x1 => I::Or { x, y },
                0x2 => I::And { x, y },
                0x3 => I::Xor { x, y },
                0x4 => I::Add {
                    x,
                    v: Value::Register(y),
                },
                0x5 => I::Sub { x, y },
                0x6 => I::Shr { x, y: Some(y) },
                0x7 => I::Subn { x, y },
                0xe => I::Shl { x, y: Some(y) },
                _ => return Err(DecodeError::InvalidSecondaryOpcode(code, byte)),
            },
            0x9 => match n {
                0x0 => I::Sne {
                    x,
                    v: Value::Register(y),
                },
                _ => return Err(DecodeError::InvalidSecondaryOpcode(code, byte)),
            },
            0xa => I::Ldi(addr),
            0xb => I::Jpv0(addr),
            0xc => I::Rnd { x, mask: byte },
            0xd => I::Drw { x, y, n },
            0xe => match byte {
                0x9e => I::Skp { x },
                0xa1 => I::Sknp { x },
                _ => return Err(DecodeError::InvalidSecondaryOpcode(code, byte)),
            },
            0xf => match byte {
                0x07 => I::Ldrdt { x },
                0x0a => I::Ldk { x },
                0x15 => I::Lddtr { x },
                0x18 => I::Ldstr { x },
                0x1e => I::Addi { x },
                0x29 => I::Ldf { x },
                0x33 => I::Ldb { x },
                0x55 => I::Strs { x },
                0x65 => I::Ldrs { x },
                _ => return Err(DecodeError::InvalidSecondaryOpcode(code, byte)),
            },
            _ => unreachable!("All 16-bit values are accounted for"),
        })
    }

    fn execute(&mut self, instruction: Instruction) {
        use Instruction as I;
        match instruction {
            I::Cls => self.display_memory = [[0x0; DISPLAY_WIDTH]; DISPLAY_HEIGHT],
            I::Ret => self.ret(),
            I::Jp(addr) => self.jump(addr),
            I::Call(addr) => self.call(addr),
            I::Se { x, v } => {
                if self.reg(x) == self.value(v) {
                    self.skip();
                }
            }
            I::Sne { x, v } => {
                if self.reg(x) != self.value(v) {
                    self.skip();
                }
            }
            I::Ld { x, v } => *self.reg_mut(x) = self.value(v),
            I::Add { x, v } => *self.reg_mut(x) += self.value(v),
            I::Or { x, y } => *self.reg_mut(x) |= self.reg(y),
            I::And { x, y } => *self.reg_mut(x) &= self.reg(y),
            I::Xor { x, y } => *self.reg_mut(x) ^= self.reg(y),
            I::Sub { x, y } => {
                self.set_flag((self.reg(x) > self.reg(y)) as u8);
                self.set_reg(x, self.reg(x).wrapping_sub(self.reg(y)));
            }
            I::Shr { x, y: _ } => {
                self.set_flag((self.reg(x) & 0x1 != 0) as u8);
                *self.reg_mut(x) >>= 1;
            }
            I::Subn { x, y } => {
                self.set_flag((self.reg(y) > self.reg(x)) as u8);
                self.set_reg(x, self.reg(y).wrapping_sub(self.reg(x)));
            }
            I::Shl { x, y: _ } => {
                self.set_flag((self.reg(x) & (0x1 << 7) != 0) as u8);
                *self.reg_mut(x) <<= 1;
            }
            I::Ldi(addr) => self.ir = addr,
            I::Jpv0(addr) => self.pc = addr + self.reg(0x0) as u16,
            I::Rnd { x, mask } => {
                let mut buf = [0];
                self.rng.fill(&mut buf);
                self.rand = buf[0];
                self.set_reg(x, self.rand & mask);
            }
            I::Drw { x, y, n } => {
                let (x, y) = (self.reg(x), self.reg(y));
                let mut sprite = vec![0x0; n as usize];
                sprite
                    .copy_from_slice(&self.memory[self.ir as usize..(self.ir + n as u16) as usize]);
                self.draw_sprite(x, y, &sprite);
            }
            I::Skp { x } => {
                if self.is_key_down(self.reg(x)) {
                    self.skip();
                }
            }
            I::Sknp { x } => {
                if !self.is_key_down(self.reg(x)) {
                    self.skip();
                }
            }
            I::Ldrdt { x } => self.set_reg(x, self.dt),
            I::Ldk { x } => {
                for (i, key) in self.input.iter().enumerate() {
                    if *key {
                        self.set_reg(x, i as u8);
                        return;
                    }
                }
                self.pc -= 2;
            }

            I::Lddtr { x } => self.dt = self.reg(x),
            I::Ldstr { x } => self.st = self.reg(x),
            I::Addi { x } => self.ir += self.reg(x) as u16,
            I::Ldf { x } => self.ir = FONTSET_ADDR + self.reg(x) as u16 * 5,
            I::Ldb { x } => {
                let vx = self.reg(x);
                let idx = self.ir as usize;
                self.memory[idx] = vx / 100;
                self.memory[idx + 1] = (vx / 10) % 10;
                self.memory[idx + 1] = vx % 10;
            }

            I::Strs { x } => {
                let x = x as usize;
                let idx = self.ir as usize;
                self.memory[idx..idx + x].copy_from_slice(&self.registers[0..x]);
            }
            I::Ldrs { x } => {
                let x = x as usize;
                let idx = self.ir as usize;
                self.registers[0..x].copy_from_slice(&self.memory[idx..idx + x]);
            }
        }
    }

    fn push(&mut self, addr: Addr) {
        self.stack[self.sp as usize] = addr;
        self.sp += 1;
    }

    fn pop(&mut self) -> Addr {
        self.sp -= 1;
        self.stack[self.sp as usize]
    }

    fn value(&self, v: Value) -> u8 {
        match v {
            Value::Register(x) => self.reg(x),
            Value::Immediate(v) => v,
        }
    }

    fn reg(&self, r: Reg) -> u8 {
        self.registers[r as usize]
    }

    fn reg_mut(&mut self, r: Reg) -> &mut u8 {
        &mut self.registers[r as usize]
    }

    fn set_reg(&mut self, r: Reg, value: u8) {
        *self.reg_mut(r) = value;
    }

    fn set_flag(&mut self, value: u8) {
        *self.reg_mut(0xf) = value;
    }

    fn jump(&mut self, addr: Addr) {
        self.pc = addr - 2;
    }

    fn call(&mut self, addr: Addr) {
        self.push(self.pc + 2);
        self.jump(addr);
    }

    fn ret(&mut self) {
        let ret = self.pop();
        self.jump(ret);
    }

    fn skip(&mut self) {
        self.pc += 2;
    }

    fn draw_sprite(&mut self, x: u8, y: u8, sprite: &[u8]) {
        self.set_flag(0x0);
        for (dy, row) in sprite.iter().enumerate() {
            for dx in 0..8 {
                let (cur_x, cur_y) = (
                    x.wrapping_add(dx) as usize,
                    y.wrapping_add(dy as u8) as usize,
                );
                let pixel = row & (0x1 << (7 - dx)) != 0;
                if pixel {
                    if self.display_memory[cur_y][cur_x] == PIXEL_ON {
                        self.set_flag(0x1);
                    }
                    self.display_memory[cur_y][cur_x] ^= self.display_memory[cur_y][cur_x];
                }
            }
        }
    }

    fn is_key_down(&self, key: u8) -> bool {
        if let Some(down) = self.input.get(key as usize) {
            *down
        } else {
            false
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_bitmask() {
        assert_eq!(bitmask(0..5), 0b00011111);
        assert_eq!(bitmask(1..6), 0b00111110);
        assert_eq!(bitmask(3..13), 0b1111111111000);
        assert_eq!(bitmask(0..16), 0b1111111111111111);
    }

    #[test]
    fn test_get_bits() {
        let v = 0b1111000011110000;

        assert_eq!(get_bits(v, 0..5), 0b10000);
        assert_eq!(get_bits(v, 2..6), 0b1100);
        assert_eq!(get_bits(v, 0..8), 0b11110000);
        assert_eq!(get_bits(v, 8..16), 0b11110000);
    }
}
