mod compiler;
mod instruction;
mod quirks;

use crate::chip8::quirks::Quirks;
use std::{
    fs::{self},
    io::{self, BufRead, Write},
    ops::{BitXor, BitXorAssign},
    path::{Path, PathBuf},
    thread,
    time::{Duration, Instant, SystemTime},
};

use clap::ValueEnum;
use instruction::{Addr, DecodeError, Instruction, Opcode, Reg, Value};
use quirks::ScrollingMode;
use rand::{Rng, SeedableRng, rngs::SmallRng};
use sdl2::{
    EventPump, event::Event, keyboard::Keycode, pixels::Color, rect::Point, render::Canvas,
};

const REGISTERS_LEN: usize = 16;
const MEM_LEN: usize = 0x1000;
const STACK_LEN: usize = 16;
const FONTSET_ADDR: Addr = 0x050;
const FONTSET_LEN: usize = 0x50;
const FONTSET: [u8; FONTSET_LEN] = [
    0xf0, 0x90, 0x90, 0x90, 0xf0, /* 0 */
    0x20, 0x60, 0x20, 0x20, 0x70, /* 1 */
    0xf0, 0x10, 0xf0, 0x80, 0xf0, /* 2 */
    0xf0, 0x10, 0xf0, 0x10, 0xf0, /* 3 */
    0x90, 0x90, 0xf0, 0x10, 0x10, /* 4 */
    0xf0, 0x80, 0xf0, 0x10, 0xf0, /* 5 */
    0xf0, 0x80, 0xf0, 0x90, 0xf0, /* 6 */
    0xf0, 0x10, 0x20, 0x40, 0x40, /* 7 */
    0xf0, 0x90, 0xf0, 0x90, 0xf0, /* 8 */
    0xf0, 0x90, 0xf0, 0x10, 0xf0, /* 9 */
    0xf0, 0x90, 0xf0, 0x90, 0x90, /* A */
    0xe0, 0x90, 0xe0, 0x90, 0xe0, /* B */
    0xf0, 0x80, 0x80, 0x80, 0xf0, /* C */
    0xe0, 0x90, 0x90, 0x90, 0xe0, /* D */
    0xf0, 0x80, 0xf0, 0x80, 0xf0, /* E */
    0xf0, 0x80, 0xf0, 0x80, 0x80, /* F */
];
const INPUT_KEYS_LEN: usize = 16;
const AUDIO_BUFFER_LEN: usize = 16;
const NUMBER_OF_PLANES: usize = 2;

const DISPLAY_WIDTH: usize = 128;
const DISPLAY_HEIGHT: usize = 64;
const PIXEL_SIZE: u32 = 5;
const COLORS: [Color; 4] = [Color::BLACK, Color::WHITE, Color::GRAY, Color::YELLOW];

const START_ADDR: Addr = 0x200;

const UPDATES_PER_SECOND: u64 = 660;

const FRAMES_PER_SECOND: u64 = 60;

const TIMER_DECREMENTS_PER_SECOND: u64 = 60;

pub const ALLOWED_FILE_EXTENSIONS: &[&str] = &["ch8"];

#[derive(Debug)]
pub struct Chip8 {
    registers: [u8; REGISTERS_LEN],
    memory: [u8; MEM_LEN],

    /** Index Register. Stores an index into memory. */
    ir: Addr,

    /** Program Counter. Stores address of currently executing instruction in memory. */
    pc: Addr,

    /** Call Stack. Stores return addresses of CALL instructions. */
    stack: [Addr; STACK_LEN],

    /** Stack Pointer. Stores index of current return address in the call stack. */
    sp: u8,

    /** Delay Timer. If not zero, decrements by one each clock cycle. */
    dt: u8,

    /** Sound Timer. Behaves the same as delay timer, but a single note will buzz when non-zero. */
    st: u8,

    /** Input Keys. Stores whether each of the 16 input keys is pressed or not pressed. */
    input: [bool; 16],

    /** Same as above but for last cycle. Used for detecting a key down-event. */
    input_last_cycle: [bool; 16],

    /** Monochrome Display Memory. A memory buffer storing the graphics to display. */
    display_memory: [[[Pixel; DISPLAY_WIDTH]; DISPLAY_HEIGHT]; NUMBER_OF_PLANES],

    /** Random Number Generator. Generates random numbers. */
    rng: SmallRng,

    /** Random Byte. The current random byte generated by the random number generator. */
    rand: u8,

    quirks: Quirks,

    is_running: bool,
    is_suspended: bool,
    is_in_extended_mode: bool,

    /** Current system tick. */
    tick: u64,

    /** RPL Flag Registers. Used to save the registers for the Super-Chip instruction. */
    rpl: [u8; REGISTERS_LEN],

    /** When the next display interrupt will be. Used for determining how long to halt when executing Draw instruction. */
    next_display_interrupt: Instant,

    /** Audio Pattern Buffer. Stores audio pattern data. */
    audio_buffer: [u8; AUDIO_BUFFER_LEN],

    /** The current audio playback rate in Hz. */
    audio_playback_rate: u32,

    /** The selected drawing places stored as a bitmask. */
    plane_mask: u8,
}

#[derive(Clone, ValueEnum, Debug)]
pub enum ChipType {
    Chip8,
    SuperChipLegacy,
    SuperChipModern,
    XoChip,
}

#[derive(Debug)]
pub enum Chip8Error {
    IndexOutOfRange(usize),
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Pixel {
    On,
    Off,
}

impl BitXor for Pixel {
    type Output = Self;

    fn bitxor(self, rhs: Self) -> Self::Output {
        match (self, rhs) {
            (Pixel::On, Pixel::On) => Pixel::Off,
            (Pixel::On, Pixel::Off) => Pixel::On,
            (Pixel::Off, Pixel::On) => Pixel::On,
            (Pixel::Off, Pixel::Off) => Pixel::Off,
        }
    }
}

impl BitXorAssign for Pixel {
    fn bitxor_assign(&mut self, rhs: Self) {
        *self = *self ^ rhs;
    }
}

pub fn find_roms(dir: &Path, search_recursively: bool) -> Vec<PathBuf> {
    fs::read_dir(dir)
        .expect("failed to list entries in dir")
        .filter_map(|p| p.ok())
        .flat_map(|p| {
            let file_type = p
                .file_type()
                .expect("failed reading file type of dir entry");
            if file_type.is_file() {
                if let Some(ext) = p.path().extension() {
                    if ALLOWED_FILE_EXTENSIONS.contains(&ext.to_str().unwrap()) {
                        vec![p.path()]
                    } else {
                        Vec::new()
                    }
                } else {
                    Vec::new()
                }
            } else if search_recursively && file_type.is_dir() {
                find_roms(&p.path(), search_recursively)
            } else {
                Vec::new()
            }
        })
        .collect()
}

pub fn run_rom_selector_cli(roms_dir: &Path) -> PathBuf {
    let stdin = io::stdin();
    let mut rom_paths = find_roms(Path::new(roms_dir), true);

    rom_paths.sort_by(|a, b| a.file_name().cmp(&b.file_name()));

    println!(
        "{}",
        rom_paths
            .iter()
            .enumerate()
            .map(|(i, p)| format!(
                "{: >3}. {}\n",
                i + 1,
                p.file_name().unwrap().to_str().unwrap()
            ))
            .fold(String::new(), |mut acc, p| {
                acc.push_str(&p);
                acc
            })
    );

    let choice = loop {
        print!("Choose a ROM: ");
        io::stdout().flush().unwrap();
        let input = stdin.lock().lines().next().unwrap().unwrap();
        if let Ok(choice) = input.trim().parse::<usize>() {
            if choice - 1 < rom_paths.len() {
                break choice - 1;
            } else {
                println!("Index {} out of range.", choice);
            }
        } else {
            println!("Error parsing {}", input);
        }
    };

    println!(
        "Running {}...",
        rom_paths[choice].file_name().unwrap().to_str().unwrap()
    );

    rom_paths[choice].clone()
}

impl Default for Chip8 {
    fn default() -> Self {
        Self::new(ChipType::Chip8)
    }
}

fn audio_hz(vx: u8) -> u32 {
    (4000.0 * 2f32.powf((vx as f32 - 64.0) / 48.0)) as u32
}

impl Chip8 {
    pub fn new(chip_type: ChipType) -> Self {
        let mut memory = [0; MEM_LEN];

        memory[FONTSET_ADDR as usize..FONTSET_ADDR as usize + FONTSET_LEN]
            .copy_from_slice(&FONTSET);

        let mut rng = SmallRng::seed_from_u64(
            SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_secs(),
        );

        let rand = rng.random_range(0x0..=u8::MAX);

        let quirks = match chip_type {
            ChipType::Chip8 => Quirks::CHIP8,
            ChipType::SuperChipLegacy => Quirks::SUPER_CHIP_LEGACY,
            ChipType::SuperChipModern => Quirks::SUPER_CHIP_MODERN,
            ChipType::XoChip => Quirks::XO_CHIP,
        };

        Self {
            registers: [0x0; REGISTERS_LEN],
            memory,
            ir: 0x0,
            pc: START_ADDR,
            stack: [0x0; STACK_LEN],
            sp: 0x0,
            dt: 0x0,
            st: 0x0,
            input: [false; INPUT_KEYS_LEN],
            input_last_cycle: [false; INPUT_KEYS_LEN],
            display_memory: [[[Pixel::Off; DISPLAY_WIDTH]; DISPLAY_HEIGHT]; NUMBER_OF_PLANES],
            rng,
            rand,
            quirks,
            is_running: false,
            is_suspended: false,
            is_in_extended_mode: false,
            tick: 0,
            rpl: [0x0; REGISTERS_LEN],
            next_display_interrupt: Instant::now(),
            audio_buffer: [0x0; AUDIO_BUFFER_LEN],
            audio_playback_rate: audio_hz(0),
            plane_mask: 0b01,
        }
    }

    pub fn load_rom<P>(&mut self, filepath: &P) -> Result<(), Chip8Error>
    where
        P: AsRef<Path> + ?Sized,
    {
        self.load(
            &fs::read(filepath).expect("failed opening ROM file"),
            START_ADDR,
        )?;
        Ok(())
    }

    fn load(&mut self, bytes: &[u8], addr: Addr) -> Result<(), Chip8Error> {
        let addr = addr as usize;
        if addr + bytes.len() > self.memory.len() {
            return Err(Chip8Error::IndexOutOfRange(addr + bytes.len() - 1));
        }
        for (dst, src) in self.memory[addr..].iter_mut().zip(bytes) {
            *dst = *src;
        }
        Ok(())
    }

    pub fn run(&mut self) {
        let sdl_ctx = sdl2::init().unwrap();
        let video = sdl_ctx.video().unwrap();

        let width = DISPLAY_WIDTH as u32 * PIXEL_SIZE;
        let height = DISPLAY_HEIGHT as u32 * PIXEL_SIZE;
        let window = video
            .window("chip8 emulator", width, height)
            .position_centered()
            .build()
            .unwrap();

        let mut events = sdl_ctx.event_pump().unwrap();

        let mut canvas = window.into_canvas().build().unwrap();
        canvas.set_draw_color(COLORS[0]);
        canvas.clear();
        canvas.present();

        let now = Instant::now();
        let duration_per_update = Duration::from_micros(1_000_000 / UPDATES_PER_SECOND);
        let mut next_update = now;

        let duration_per_frame = Duration::from_micros(1_000_000 / FRAMES_PER_SECOND);
        self.next_display_interrupt = now;

        let duration_per_timer_decrement =
            Duration::from_micros(1_000_000 / TIMER_DECREMENTS_PER_SECOND);
        let mut next_timer_decrement = now;

        self.is_running = true;

        while self.is_running {
            self.handle_events(&mut events);

            if Instant::now() >= next_timer_decrement {
                next_timer_decrement += duration_per_timer_decrement;
                if self.dt > 0 {
                    self.dt -= 1;
                }
                if self.st > 0 {
                    self.st -= 1;
                }
            }

            if Instant::now() >= self.next_display_interrupt {
                self.next_display_interrupt += duration_per_frame;
                self.render(&mut canvas).expect("rendering driver failed");
            }

            if Instant::now() >= next_update {
                next_update += duration_per_update;

                if !self.is_suspended {
                    self.cycle();
                }
            }

            thread::sleep(Duration::from_micros(10));
        }
    }

    fn handle_events(&mut self, events: &mut EventPump) {
        fn keycode_to_input(keycode: Keycode) -> Option<usize> {
            Some(match keycode {
                Keycode::NUM_1 => 0x1,
                Keycode::NUM_2 => 0x2,
                Keycode::NUM_3 => 0x3,
                Keycode::NUM_4 => 0xc,
                Keycode::Q => 0x4,
                Keycode::W => 0x5,
                Keycode::E => 0x6,
                Keycode::R => 0xd,
                Keycode::A => 0x7,
                Keycode::S => 0x8,
                Keycode::D => 0x9,
                Keycode::F => 0xe,
                Keycode::Z => 0xa,
                Keycode::X => 0x0,
                Keycode::C => 0xb,
                Keycode::V => 0xf,
                _ => return None,
            })
        }

        self.input_last_cycle = self.input;

        for event in events.poll_iter() {
            match event {
                Event::Quit { .. }
                | Event::KeyDown {
                    keycode: Some(Keycode::ESCAPE),
                    ..
                } => self.is_running = false,
                Event::KeyDown {
                    keycode: Some(keycode),
                    ..
                } => {
                    if let Some(input) = keycode_to_input(keycode) {
                        self.input[input] = true;
                    } else {
                        match keycode {
                            Keycode::H => self.print_registers(),
                            Keycode::P => {
                                if self.is_suspended {
                                    println!("Resuming...");
                                } else {
                                    println!("Suspending...");
                                }
                                self.is_suspended = !self.is_suspended;
                            }
                            _ => {}
                        }
                    }
                }
                Event::KeyUp {
                    keycode: Some(keycode),
                    ..
                } => {
                    if let Some(input) = keycode_to_input(keycode) {
                        self.input[input] = false;
                    }
                }
                _ => {}
            }
        }
    }

    fn render(&self, canvas: &mut Canvas<sdl2::video::Window>) -> Result<(), String> {
        canvas.set_draw_color(COLORS[0]);
        canvas.clear();

        canvas.set_scale(PIXEL_SIZE as f32, PIXEL_SIZE as f32)?;
        for (y, row) in self.get_display_bitmap().iter().enumerate() {
            for (x, bitmap) in row.iter().enumerate() {
                canvas.set_draw_color(COLORS[*bitmap as usize]);
                canvas.draw_point(Point::new(x as i32, y as i32))?;
            }
        }

        canvas.present();
        Ok(())
    }

    fn get_display_bitmap(&self) -> [[u8; DISPLAY_WIDTH]; DISPLAY_HEIGHT] {
        let mut output = [[0x0; DISPLAY_WIDTH]; DISPLAY_HEIGHT];
        for (y, row) in output.iter_mut().enumerate() {
            for (x, pixel) in row.iter_mut().enumerate() {
                for (i, plane) in self.display_memory.iter().enumerate() {
                    if plane[y][x] == Pixel::On {
                        *pixel |= 0x1 << i;
                    }
                }
            }
        }
        output
    }

    fn get_selected_planes(&self) -> Vec<usize> {
        (0..NUMBER_OF_PLANES)
            .filter(|i| (0x1 << i) & self.plane_mask != 0)
            .collect()
    }

    fn clear(&mut self) {
        for plane in self.get_selected_planes() {
            self.display_memory[plane] = [[Pixel::Off; DISPLAY_WIDTH]; DISPLAY_HEIGHT];
        }
    }

    fn scroll_display(&mut self, dx: i8, dy: i8) {
        let (dx, dy) = match (self.is_in_extended_mode, self.quirks.scrolling) {
            (false, ScrollingMode::Logical) => (dx * 2, dy * 2),
            _ => (dx, dy),
        };
        for plane in self.get_selected_planes() {
            let mut buf = [[Pixel::Off; DISPLAY_WIDTH]; DISPLAY_HEIGHT];
            for (y, row) in buf.iter_mut().enumerate() {
                for (x, pixel) in row.iter_mut().enumerate() {
                    let (src_x, src_y) = (
                        x.wrapping_add_signed(-dx as isize),
                        y.wrapping_add_signed(-dy as isize),
                    );
                    *pixel = if src_x < DISPLAY_WIDTH && src_y < DISPLAY_HEIGHT {
                        self.display_memory[plane][src_y][src_x]
                    } else {
                        Pixel::Off
                    };
                }
            }
            self.display_memory[plane] = buf;
        }
    }

    fn cycle(&mut self) {
        let opcode = self.get_be_u16(self.pc);
        match Instruction::decode(opcode) {
            Ok(instruction) => self.execute(instruction),
            Err(DecodeError::InvalidSecondaryOpcode(code, secondary)) => panic!(
                "Invalid opcode {:0>4x} (first opcode: {:0>2x}, secondary opcode: {:0>2x})",
                opcode, code, secondary
            ),
        }
        self.pc += 2;
        self.tick += 1;
    }

    fn get_be_u16(&self, addr: Addr) -> Opcode {
        let addr = addr as usize;
        ((self.memory[addr] as u16) << u8::BITS) | self.memory[addr + 1] as u16
    }

    fn execute(&mut self, instruction: Instruction) {
        use Instruction as I;
        match instruction {
            I::Suspend => self.is_suspended = true,
            I::ScrollDown(n) => self.scroll_display(0, n as i8),
            I::ScrollUp(n) => self.scroll_display(0, -(n as i8)),
            I::Clear => self.clear(),
            I::Return => self.ret(),
            I::ScrollRight => self.scroll_display(4, 0),
            I::ScrollLeft => self.scroll_display(-4, 0),
            I::ExitChip => self.is_running = false,
            I::DisableExtendedScreen => self.is_in_extended_mode = false,
            I::EnableExtendedScreen => self.is_in_extended_mode = true,
            I::Jump(addr) => self.jump(addr),
            I::Call(addr) => self.call(addr),
            I::SkipIfEqual { x, v } => {
                if self.reg(x) == self.value(v) {
                    self.skip();
                }
            }
            I::SkipIfNotEqual { x, v } => {
                if self.reg(x) != self.value(v) {
                    self.skip();
                }
            }
            I::SaveRegisterRange { x, y } => {
                let is_reversed = y < x;
                let (start, end) = if is_reversed {
                    (y as usize, x as usize + 1)
                } else {
                    (x as usize, y as usize + 1)
                };
                let (ir, len) = (self.ir as usize, end - start);
                self.memory[ir..ir + len].copy_from_slice(&self.registers[start..end]);
                if is_reversed {
                    self.memory[ir..ir + len].reverse();
                }
            }
            I::LoadRegisterRange { x, y } => {
                let is_reversed = y < x;
                let (start, end) = if is_reversed {
                    (y as usize, x as usize + 1)
                } else {
                    (x as usize, y as usize + 1)
                };
                let (ir, len) = (self.ir as usize, end - start);
                self.registers[start..end].copy_from_slice(&self.memory[ir..ir + len]);
                if is_reversed {
                    self.registers[start..end].reverse();
                }
            }
            I::Load { x, v } => *self.reg_mut(x) = self.value(v),
            I::Add { x, v } => {
                let (lhs, rhs) = (self.reg(x), self.value(v));
                self.set_reg(x, lhs.wrapping_add(rhs));
                self.set_flag((lhs as u16 + rhs as u16 > u8::MAX as u16) as u8);
            }
            I::Or { x, y } => {
                *self.reg_mut(x) |= self.reg(y);
                if self.quirks.vf_reset {
                    self.set_flag(0);
                }
            }
            I::And { x, y } => {
                *self.reg_mut(x) &= self.reg(y);
                if self.quirks.vf_reset {
                    self.set_flag(0);
                }
            }
            I::Xor { x, y } => {
                *self.reg_mut(x) ^= self.reg(y);
                if self.quirks.vf_reset {
                    self.set_flag(0);
                }
            }
            I::Sub { x, y } => {
                let (lhs, rhs) = (self.reg(x), self.reg(y));
                self.set_reg(x, lhs.wrapping_sub(rhs));
                self.set_flag((lhs >= rhs) as u8);
            }
            I::ShiftRight { x, y } => {
                let lhs = if self.quirks.shifting {
                    self.reg(x)
                } else {
                    self.reg(y)
                };
                self.set_reg(x, lhs >> 1);
                self.set_flag((lhs & 0x1 != 0) as u8);
            }
            I::SubNegative { x, y } => {
                let (lhs, rhs) = (self.reg(x), self.reg(y));
                self.set_reg(x, rhs.wrapping_sub(lhs));
                self.set_flag((rhs >= lhs) as u8);
            }
            I::ShiftLeft { x, y } => {
                let lhs = if self.quirks.shifting {
                    self.reg(x)
                } else {
                    self.reg(y)
                };
                self.set_reg(x, lhs << 1);
                self.set_flag((lhs & (0x1 << 7) != 0) as u8);
            }
            I::LoadIndex(addr) => self.ir = addr,
            I::JumpOffset { x, addr } => {
                let offset = if self.quirks.jumping {
                    self.reg(x)
                } else {
                    self.reg(0x0)
                };
                self.jump(addr + offset as u16);
            }
            I::Random { x, mask } => {
                let mut buf = [0];
                self.rng.fill(&mut buf);
                self.rand = buf[0];
                self.set_reg(x, self.rand & mask);
            }
            I::Draw { x, y, n } => self.draw(x, y, n),
            I::SkipIfKeyPressed { x } => {
                if self.is_key_down(self.reg(x)) {
                    self.skip();
                }
            }
            I::SkipIfKeyNotPressed { x } => {
                if !self.is_key_down(self.reg(x)) {
                    self.skip();
                }
            }
            I::LoadLongIndex => {
                self.skip();
                self.ir = self.get_be_u16(self.pc);
            }
            I::LoadAudio => {
                let (ir, len) = (self.ir as usize, self.audio_buffer.len());
                self.audio_buffer
                    .copy_from_slice(&self.memory[ir..ir + len]);
            }
            I::SelectPlane { mask } => self.plane_mask = mask,
            I::LoadDtIntoRegister { x } => self.set_reg(x, self.dt),
            I::LoadKeyPress { x } => {
                for (i, (pressed, pressed_last_cycle)) in
                    self.input.iter().zip(&self.input_last_cycle).enumerate()
                {
                    if *pressed && !*pressed_last_cycle {
                        self.set_reg(x, i as u8);
                        return;
                    }
                }
                self.pc -= 2;
            }
            I::LoadRegisterIntoDt { x } => self.dt = self.reg(x),
            I::LoadRegisterIntoSt { x } => self.st = self.reg(x),
            I::AddIndex { x } => self.ir += self.reg(x) as u16,
            I::LoadFont { x } => self.ir = FONTSET_ADDR + self.reg(x) as u16 * 5,
            I::LoadHiResFont { x: _ } => todo!(),
            I::LoadBcd { x } => {
                let vx = self.reg(x);
                let idx = self.ir as usize;
                self.memory[idx] = vx / 100;
                self.memory[idx + 1] = (vx / 10) % 10;
                self.memory[idx + 2] = vx % 10;
            }
            I::SetPitch { x } => {
                self.audio_playback_rate = audio_hz(self.reg(x));
            }
            I::StoreRegisters { x } => {
                let x = x as usize + 1;
                let idx = self.ir as usize;
                self.memory[idx..idx + x].copy_from_slice(&self.registers[..x]);
                if self.quirks.memory {
                    self.ir += x as u16;
                }
            }
            I::LoadRegisters { x } => {
                let x = x as usize + 1;
                let idx = self.ir as usize;
                self.registers[..x].copy_from_slice(&self.memory[idx..idx + x]);
                if self.quirks.memory {
                    self.ir += x as u16;
                }
            }
            I::StoreRegistersRPL { x } => {
                let x = x as usize + 1;
                self.rpl[..x].copy_from_slice(&self.registers[..x]);
            }
            I::LoadRegistersRPL { x } => {
                let x = x as usize + 1;
                self.registers[..x].copy_from_slice(&self.rpl[..x]);
            }
        }
    }

    fn push(&mut self, addr: Addr) {
        self.stack[self.sp as usize] = addr;
        self.sp += 1;
    }

    fn pop(&mut self) -> Addr {
        self.sp -= 1;
        self.stack[self.sp as usize]
    }

    fn value(&self, v: Value) -> u8 {
        match v {
            Value::Register(x) => self.reg(x),
            Value::Immediate(v) => v,
        }
    }

    fn reg(&self, r: Reg) -> u8 {
        self.registers[r as usize]
    }

    fn reg_mut(&mut self, r: Reg) -> &mut u8 {
        &mut self.registers[r as usize]
    }

    fn set_reg(&mut self, r: Reg, value: u8) {
        *self.reg_mut(r) = value;
    }

    fn set_flag(&mut self, value: u8) {
        *self.reg_mut(0xf) = value;
    }

    fn jump(&mut self, addr: Addr) {
        self.pc = addr - 2;
    }

    fn call(&mut self, addr: Addr) {
        self.push(self.pc + 2);
        self.jump(addr);
    }

    fn ret(&mut self) {
        let ret = self.pop();
        self.jump(ret);
    }

    fn skip(&mut self) {
        self.pc += 2;
        /* Skip the double wide instruction (if present) */
        if self.get_be_u16(self.pc) == 0xf000 {
            self.pc += 2;
        }
    }

    fn display_width(&self) -> usize {
        if self.is_in_extended_mode {
            DISPLAY_WIDTH
        } else {
            DISPLAY_WIDTH / 2
        }
    }

    fn display_height(&self) -> usize {
        if self.is_in_extended_mode {
            DISPLAY_HEIGHT
        } else {
            DISPLAY_HEIGHT / 2
        }
    }

    fn draw(&mut self, x: Reg, y: Reg, sprite_len: u8) {
        let (x, y) = (self.reg(x), self.reg(y));
        for plane in self.get_selected_planes() {
            let (mut sprite, width) = if sprite_len == 0 {
                (vec![0x0; 32], 2)
            } else {
                (vec![0x0; sprite_len as usize], 1)
            };
            let (ir, len) = (self.ir as usize + sprite.len() * plane, sprite.len());
            sprite.copy_from_slice(&self.memory[ir..ir + len]);

            if self.quirks.display_wait {
                /* Wait until right after next screen refresh to draw sprite. */
                let updates_per_frame = UPDATES_PER_SECOND / FRAMES_PER_SECOND;
                /* `UPDATES_PER_SECOND` must be a multiple of `FRAMES_PER_SECOND` for this to be correct */
                if self.tick % updates_per_frame != 0 {
                    self.pc -= 2;
                    return;
                }
            }

            self.draw_sprite(x, y, &sprite, width, plane);
        }
    }

    fn draw_sprite(&mut self, x: u8, y: u8, sprite: &[u8], width: usize, plane: usize) {
        self.set_flag(0x0);
        let (x, y) = (
            x as usize % self.display_width(),
            y as usize % self.display_height(),
        );
        let mut collided_rows = Vec::new();
        for i in 0..sprite.len() * 8 {
            let bit_index = 8 - (i % 8) - 1;
            let byte_index = i / 8;
            let (dx, dy) = (i % (width * 8), i / (width * 8));
            let (cur_x, cur_y) = if self.quirks.clipping {
                (x + dx, y + dy)
            } else {
                (
                    (x + dx) % self.display_width(),
                    (y + dy) % self.display_height(),
                )
            };
            if cur_y >= self.display_height() {
                if !collided_rows.contains(&dy) {
                    collided_rows.push(dy);
                }
                continue;
            }
            if cur_x >= self.display_width() {
                continue;
            }
            let pixel = sprite[byte_index] & (0x1 << bit_index) != 0;
            if pixel {
                if self.get_pixel(cur_x, cur_y, plane) == Pixel::On && !collided_rows.contains(&dy)
                {
                    collided_rows.push(dy);
                }
                self.draw_pixel(cur_x, cur_y, plane);
            }
        }
        if self.is_in_extended_mode {
            self.set_flag(collided_rows.len() as u8);
        } else {
            self.set_flag((!collided_rows.is_empty()) as u8);
        }
    }

    fn get_pixel(&self, x: usize, y: usize, plane: usize) -> Pixel {
        let (x, y) = if self.is_in_extended_mode {
            (x, y)
        } else {
            (x * 2, y * 2)
        };
        self.display_memory[plane][y][x]
    }

    fn draw_pixel(&mut self, x: usize, y: usize, plane: usize) {
        let (x, y) = if self.is_in_extended_mode {
            (x, y)
        } else {
            /* If in low-res mode, pixels are 2x2 and coordinates for drawing are doubled */
            (x * 2, y * 2)
        };
        self.display_memory[plane][y][x] ^= Pixel::On;
        if !self.is_in_extended_mode {
            self.display_memory[plane][y + 1][x] ^= Pixel::On;
            self.display_memory[plane][y][x + 1] ^= Pixel::On;
            self.display_memory[plane][y + 1][x + 1] ^= Pixel::On;
        }
    }

    fn is_key_down(&self, key: u8) -> bool {
        if let Some(down) = self.input.get(key as usize) {
            *down
        } else {
            false
        }
    }

    fn print_registers(&self) {
        println!("\nPC: 0x{:0>3x}, IR: 0x{:0>3x}", self.pc, self.ir);
        println!(
            "V0: 0x{:0>2x}, V1: 0x{:0>2x}, V2: 0x{:0>2x}, V3: 0x{:0>2x}",
            self.reg(0x0),
            self.reg(0x1),
            self.reg(0x2),
            self.reg(0x3)
        );
        println!(
            "V4: 0x{:0>2x}, V5: 0x{:0>2x}, V6: 0x{:0>2x}, V7: 0x{:0>2x}",
            self.reg(0x4),
            self.reg(0x5),
            self.reg(0x6),
            self.reg(0x7)
        );
        println!(
            "V8: 0x{:0>2x}, V9: 0x{:0>2x}, VA: 0x{:0>2x}, VB: 0x{:0>2x}",
            self.reg(0x8),
            self.reg(0x9),
            self.reg(0xa),
            self.reg(0xb)
        );
        println!(
            "VC: 0x{:0>2x}, VD: 0x{:0>2x}, VE: 0x{:0>2x}, VF: 0x{:0>2x}",
            self.reg(0xc),
            self.reg(0xd),
            self.reg(0xe),
            self.reg(0xf)
        );
        println!(
            "SP: 0x{:0>2x}, DT: 0x{:0>2x}, ST: 0x{:0>2x}",
            self.sp, self.dt, self.st
        );
    }
}
